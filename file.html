<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Dibash Blogs</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/atom-one-dark.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/highlight.min.js"></script>
    <link
      href="https://fonts.googleapis.com/css?family=Open+Sans:400,600,300"
      rel="stylesheet"
      type="text/css"
    />

    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/languages/rust.min.js"></script> -->
    <style>
      body {
        font-family: "Open Sans";
        font-size: 1.6rem;
      }
    </style>
  </head>
  <body>
    <hr />
    <p>
      title: &quot;The curse of strong typing&quot; date:
      &quot;2022-06-01T07:30:00Z&quot; tags:
    </p>
    <ul>
      <li>rust</li>
      <li>async extra: patreon: true</li>
    </ul>
    <hr />
    <p>It happened when I least expected it.</p>
    <p>
      Someone, <em>somewhere</em> (above me, presumably) made a decision.
      &quot;From now on&quot;, they declared, &quot;all our new stuff must be
      written in Rust&quot;.
    </p>
    <p>
      I'm not sure where they got that idea from. Maybe they've been reading
      <a
        href="https://www.zdnet.com/article/microsoft-70-percent-of-all-security-bugs-are-memory-safety-issues/"
        >propaganda</a
      >. Maybe they fell prey to some
      <a href="/tags/rust">confident asshole</a>, and convinced themselves that
      Rust was <em>the</em> answer to their problems.
    </p>
    <p>
      I don't know what they see in it, to be honest. It's like I always say:
      it's not a data race, it's a data marathon.
    </p>
    <p>
      At any rate, I now find myself in a beautiful house<a
        href="https://www.youtube.com/watch?v=5IsSpAOD6K8"
        >,</a
      >
      with a beautiful wife, and a <em>lot</em> of compile errors.
    </p>
    <p>
      Jesus that's a lot of compile errors<a
        href="https://knowyourmeme.com/memes/fortune-teller"
        >.</a
      >
    </p>
    <h2>Different kinds of numbers</h2>
    <p>
      And it's not like I'm resisting progress! When someone made the case for
      using
      <a href="https://en.wikipedia.org/wiki/Tau">tau</a> instead of pi, I was
      the first to hop on the bandwagon.
    </p>
    <p>But Rust won't even let me do <em>that</em>:</p>
    <pre><code class="language-rust">fn main() {
    // only nerds need more digits
    println!(&quot;tau = {}&quot;, 2 * 3.14159265);
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
error[E0277]: cannot multiply `{integer}` by `{float}`
 --&gt; src/main.rs:3:28
  |
3 |     println!(&quot;tau = {}&quot;, 2 * 3.14159265);
  |                            ^ no implementation for `{integer} * {float}`
  |
  = help: the trait `Mul&lt;{float}&gt;` is not implemented for `{integer}`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `grr` due to previous error
</code></pre>
    <p>
      When it <em>clearly</em> works in
      <a href="https://en.wikipedia.org/wiki/ECMAScript">ECMAScript</a> for
      example:
    </p>
    <pre><code class="language-javascript">// in `main.js`

// TODO: ask for budget increase so we can afford more digits
console.log(`tau = ${2 * 3.14159265}`);
</code></pre>
    <pre><code class="language-shell">$ node main.js
tau = 6.2831853
</code></pre>
    <p>Luckily, a colleague rushes in to help me.</p>
    <p>
      {% sc bearsays %} Well those... those are different types. {% endsc %}
    </p>
    <p>Types? Never heard of them.</p>
    <p>
      {% sc bearsays %} You've seen the title of this post right? Strong typing?
      {% endsc %}
    </p>
    <p>
      Fine, I'll look it up. It
      <a
        href="https://en.wikipedia.org/wiki/Strong_and_weak_typing#Definitions_of_%22strong%22_or_%22weak%22"
        >says here</a
      >
      that:
    </p>
    <blockquote>
      <p>
        &quot;Strong typing&quot; generally refers to use of programming
        language types in order to both capture invariants of the code, and
        ensure its correctness, and definitely exclude certain classes of
        programming errors. Thus there are many &quot;strong typing&quot;
        disciplines used to achieve these goals.
      </p>
    </blockquote>
    <p>Okay. What's incorrect about my code?</p>
    <p>
      {% sc bearsays %} Oh, nothing! Nothing at all. These are just different
      types. {% endsc %}
    </p>
    <p>So it's just getting in the way right now yes, correct?</p>
    <p>
      {% sc bearsays %} Well... sort of? But it's not like your program is
      running on an imaginary machine. There's a real difference between an
      &quot;integer&quot; and a &quot;floating point number&quot;. {% endsc %}
    </p>
    <p>A floa-</p>
    <p>{% sc bearsays %} Look at this for example: {% endsc %}</p>
    <pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	a := 200000000
	for i := 0; i &lt; 10; i++ {
		a *= 10
		fmt.Printf(&quot;a = %v\n&quot;, a)
	}
}

</code></pre>
    <pre><code class="language-shell">$ go run main.go
a = 2000000000
a = 20000000000
a = 200000000000
a = 2000000000000
a = 20000000000000
a = 200000000000000
a = 2000000000000000
a = 20000000000000000
a = 200000000000000000
a = 2000000000000000000
</code></pre>
    <p>Yeah, that makes perfect sense! What's your point?</p>
    <p>{% sc bearsays %} Well, if we keep going a little more... {% endsc %}</p>
    <pre><code class="language-go">package main

import &quot;fmt&quot;

func main() {
	a := 200000000
	//              👇
	for i := 0; i &lt; 15; i++ {
		a *= 10
		fmt.Printf(&quot;a = %v\n&quot;, a)
	}
}
</code></pre>
    <pre><code class="language-shell">$ go run main.go
a = 2000000000
a = 20000000000
a = 200000000000
a = 2000000000000
a = 20000000000000
a = 200000000000000
a = 2000000000000000
a = 20000000000000000
a = 200000000000000000
a = 2000000000000000000
a = 1553255926290448384
a = -2914184810805067776
a = 7751640039368425472
a = 3729424098846048256
a = 400752841041379328
</code></pre>
    <p>Oh. Oh no.</p>
    <p>
      {% sc bearsays %} That's an <em>overflow</em>. We used a 64-bit integer
      variable, and to represent 2000000000000000000, we'd need 64.12 bits,
      which... that's more than we have. {% endsc %}
    </p>
    <p>Okay, but <em>again</em> this works in ECMAScript for example:</p>
    <pre><code class="language-javascript">let a = 200000000;
for (let i = 0; i &lt; 15; i++) {
  a *= 10;
  console.log(`a = ${a}`);
}
</code></pre>
    <pre><code class="language-shell">$ node main.js
a = 2000000000
a = 20000000000
a = 200000000000
a = 2000000000000
a = 20000000000000
a = 200000000000000
a = 2000000000000000
a = 20000000000000000
a = 200000000000000000
a = 2000000000000000000
a = 20000000000000000000
a = 200000000000000000000
a = 2e+21
a = 2e+22
a = 2e+23
</code></pre>
    <p>
      Sure, it's using
      <a href="https://en.wikipedia.org/wiki/Scientific_notation#E_notation"
        >nerd notation</a
      >, but if we just go back, we can see it's working:
    </p>
    <pre><code class="language-javascript">let a = 200000000;

for (let i = 0; i &lt; 15; i++) {
  a *= 10;
  console.log(`a = ${a}`);
}

console.log(&quot;turn back!&quot;);

for (let i = 0; i &lt; 15; i++) {
  a /= 10;
  console.log(`a = ${a}`);
}
</code></pre>
    <pre><code class="language-shell">$ node main.js
a = 2000000000
a = 20000000000
a = 200000000000
a = 2000000000000
a = 20000000000000
a = 200000000000000
a = 2000000000000000
a = 20000000000000000
a = 200000000000000000
a = 2000000000000000000
a = 20000000000000000000
a = 200000000000000000000
a = 2e+21
a = 2e+22
a = 2e+23
turn back!
a = 2e+22
a = 2e+21
a = 200000000000000000000
a = 20000000000000000000
a = 2000000000000000000
a = 200000000000000000
a = 20000000000000000
a = 2000000000000000
a = 200000000000000
a = 20000000000000
a = 2000000000000
a = 200000000000
a = 20000000000
a = 2000000000
a = 200000000
</code></pre>
    <p>Mhh, looks like döner kebab.</p>
    <p>
      {% sc bearsays %} Okay, but those are floating point numbers. {% endsc %}
    </p>
    <p>They don't look very floating to me.</p>
    <p>{% sc bearsays %} Consider this: {% endsc %}</p>
    <pre><code class="language-javascript">let a = 0.1;
let b = 0.2;
let sum = a + b;

console.log(sum);
</code></pre>
    <pre><code class="language-shell">$ node main.js
0.30000000000000004
</code></pre>
    <p>Ah, that... that does float.</p>
    <p>
      {% sc bearsays %} Yeah, and that's
      <a href="https://en.wikipedia.org/wiki/IEEE_754">the trade-off</a>. You
      get to represent numbers that aren't whole numbers, and also /very large/
      numbers, at the expense of some precision. {% endsc %}
    </p>
    <p>I see.</p>
    <p>
      {% sc bearsays %} For example, with floats, you can compute two thirds: {%
      endsc %}
    </p>
    <pre><code class="language-rust">fn main() {
    println!(&quot;two thirds = {}&quot;, 2.0 / 3.0);
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
two thirds = 0.6666666666666666
</code></pre>
    <p>{% sc bearsays %} But with integers, you can't: {% endsc %}</p>
    <pre><code class="language-rust">fn main() {
    println!(&quot;two thirds = {}&quot;, 2 / 3);
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
two thirds = 0
</code></pre>
    <p>Wait, but I don't see any actual types here. Just values.</p>
    <p>{% sc bearsays %} Yeah, it's all inferred! {% endsc %}</p>
    <p>
      I uh. Okay I'm still confused. See, in ECMAScript, a number's a number:
    </p>
    <pre><code class="language-javascript">console.log(typeof 36);
console.log(typeof 42.28);
</code></pre>
    <pre><code class="language-shell">$ node main.js
number
number
</code></pre>
    <p>{% sc bearsays %} Unless it's a big number! {% endsc %}</p>
    <pre><code class="language-javascript">console.log(typeof 36);
console.log(typeof 42.28);
console.log(typeof 248672936507863405786027355423684n);
</code></pre>
    <pre><code class="language-shell">$ node main.js
number
number
bigint
</code></pre>
    <p>Ahhh. So ECMAScript <em>does</em> have integers.</p>
    <p>
      {% sc bearsays %} Only big ones. Well they can smol if you want to.
      Operations just... are
      <a href="https://jsbench.me/8fl3fr31ug/1">more expensive</a> on them. {%
      endsc %}
    </p>
    <p>What about Python? Does Python have integers?</p>
    <pre><code class="language-shell">$ python3 -q
&gt;&gt;&gt; type(38)
&lt;class 'int'&gt;
&gt;&gt;&gt; type(38.139582735)
&lt;class 'float'&gt;
&gt;&gt;&gt;
</code></pre>
    <p>Mh, yeah, it does!</p>
    <p>{% sc bearsays %} Try computing two thirds with it! {% endsc %}</p>
    <pre><code class="language-shell">$ python3 -q
&gt;&gt;&gt; 2/3
0.6666666666666666
&gt;&gt;&gt; type(2)
&lt;class 'int'&gt;
&gt;&gt;&gt; type(2/3)
&lt;class 'float'&gt;
&gt;&gt;&gt;
</code></pre>
    <p>
      Hey that works! So the <code>/</code> operator in python takes two
      <code>int</code> values and gives a <code>float</code>.
    </p>
    <p>
      {% sc bearsays %} Not two <code>int</code> values. Two numbers. Could be
      anything. {% endsc %}
    </p>
    <pre><code class="language-shell">$ python3 -q
&gt;&gt;&gt; 2.8 / 1.4
2.0
&gt;&gt;&gt;
</code></pre>
    <p>What if I want to do integer division?</p>
    <p>{% sc bearsays %} There's an operator for that! {% endsc %}</p>
    <pre><code class="language-shell">$ python3 -q
&gt;&gt;&gt; 10 // 3
3
&gt;&gt;&gt;
</code></pre>
    <p>
      {% sc bearsays %} Similarly, for addition you have <code>++</code>... {%
      endsc %}
    </p>
    <pre><code class="language-shell">$ python3 -q
&gt;&gt;&gt; 2 + 3
5
&gt;&gt;&gt; 2 ++ 3
5
&gt;&gt;&gt;
</code></pre>
    <p>{% sc bearsays %} And so on... {% endsc %}</p>
    <pre><code class="language-shell">&gt;&gt;&gt; 8 - 3
5
&gt;&gt;&gt; 8 -- 3
11
</code></pre>
    <p>Wait, no, I th-</p>
    <pre><code class="language-shell">&gt;&gt;&gt; 8 * 3
24
&gt;&gt;&gt; 8 ** 3
512
</code></pre>
    <p>
      {% sc bearsays %} Woops, my bad — I guess it's just <code>//</code>.
      <code>a ++ b</code> really is <code>a + (+b)</code>,
      <code>a -- b</code> is <code>a - (-b)</code>, and <code>a ** b</code> is
      <code>a</code> to the <code>b</code>th power. {% endsc %}
    </p>
    <p>
      Okay so Python values have types, you just can't see them unless you ask.
    </p>
    <p>Can I see the types of Rust values too?</p>
    <p>{% sc bearsays %} Kinda! You can do this: {% endsc %}</p>
    <pre><code class="language-rust">fn main() {
    dbg!(type_name_of(2));
    dbg!(type_name_of(268.2111));
}

fn type_name_of&lt;T&gt;(_: T) -&gt; &amp;'static str {
    std::any::type_name::&lt;T&gt;()
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
[src/main.rs:2] type_name_of(2) = &quot;i32&quot;
[src/main.rs:3] type_name_of(268.2111) = &quot;f64&quot;
</code></pre>
    <p>
      Okay. And so in Rust, a value like <code>42</code> defaults to
      <code>i32</code> (signed 32-bit integer), and a value like
      <code>3.14</code> defaults to <code>f64</code>.
    </p>
    <p>How do I make other number types? Surely there's other.</p>
    <p>{% sc bearsays %} For literals, you can use suffixes: {% endsc %}</p>
    <pre><code class="language-shell">$ cargo run --quiet
[src/main.rs:2] type_name_of(1_u8) = &quot;u8&quot;
[src/main.rs:3] type_name_of(1_u16) = &quot;u16&quot;
[src/main.rs:4] type_name_of(1_u32) = &quot;u32&quot;
[src/main.rs:5] type_name_of(1_u64) = &quot;u64&quot;
[src/main.rs:6] type_name_of(1_u128) = &quot;u128&quot;
[src/main.rs:8] type_name_of(1_i8) = &quot;i8&quot;
[src/main.rs:9] type_name_of(1_i16) = &quot;i16&quot;
[src/main.rs:10] type_name_of(1_i32) = &quot;i32&quot;
[src/main.rs:11] type_name_of(1_i64) = &quot;i64&quot;
[src/main.rs:12] type_name_of(1_i128) = &quot;i128&quot;
[src/main.rs:14] type_name_of(1_f32) = &quot;f32&quot;
[src/main.rs:15] type_name_of(1_f64) = &quot;f64&quot;
</code></pre>
    <p>No <code>f128</code>?</p>
    <p>
      {% sc bearsays %}
      <a href="https://docs.rs/f128/latest/f128/">Not builtin</a>, no. For now.
      {% endsc %}
    </p>
    <p>Okay, so my original code here didn't work:</p>
    <pre><code class="language-rust">fn main() {
    // only nerds need more digits
    println!(&quot;tau = {}&quot;, 2 * 3.14159265);
}
</code></pre>
    <p>
      Was because the <code>2</code> on the left is an integer, and the
      <code>3.14159265</code> is a floating point number, and so I have to do
      this:
    </p>
    <pre><code class="language-rust">    println!(&quot;tau = {}&quot;, 2.0 * 3.14159265);
</code></pre>
    <p>Or this:</p>
    <pre><code class="language-rust">    println!(&quot;tau = {}&quot;, 2f64 * 3.14159265);
</code></pre>
    <p>
      Or this, to be more readable, since apparently you can stuff
      <code>_</code> anywhere in number literals:
    </p>
    <pre><code class="language-rust">    println!(&quot;tau = {}&quot;, 2_f64 * 3.14159265);
</code></pre>
    <p>
      {% sc recap %} In ECMAScript, you have 64-bit floats
      (<code>number</code>), and bigints. Operations on bigints are
      significantly more expensive than operations on floats.
    </p>
    <p>
      In Python, you have floats, and integers. Python 3 handles bigints
      seamlessly: doing arithmetic on small integer values is still
      &quot;cheap&quot;.
    </p>
    <p>
      In languages like Rust, you have integers and floats, but you need to pick
      a bit width. Number literals will default to <code>i32</code> and
      <code>f64</code>, unless you add a suffix or... some other conditions
      described in the next section. {% endsc %}
    </p>
    <h2>Conversions and type inference</h2>
    <p>Okay, I think I get it.</p>
    <p>
      So whereas Python has an &quot;integer&quot; and &quot;float&quot; type,
      Rust has different widths of integer types, like C and other system
      languages.
    </p>
    <p>So this doesn't work:</p>
    <pre><code class="language-rust">fn main() {
    let val = 280_u32;
    takes_u32(val);
    takes_u64(val);
}

fn takes_u32(val: u32) {
    dbg!(val);
}

fn takes_u64(val: u64) {
    dbg!(val);
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
error[E0308]: mismatched types
 --&gt; src/main.rs:4:15
  |
4 |     takes_u64(val);
  |               ^^^ expected `u64`, found `u32`
  |
help: you can convert a `u32` to a `u64`
  |
4 |     takes_u64(val.into());
  |                  +++++++

For more information about this error, try `rustc --explain E0308`.
error: could not compile `grr` due to previous error
</code></pre>
    <p>
      And the compiler gives me a suggestion, but according to the heading of
      the section, <code>as</code> should work, too:
    </p>
    <pre><code class="language-rust">    takes_u64(val as u64);
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
[src/main.rs:8] val = 280
[src/main.rs:12] val = 280
</code></pre>
    <p>
      {% sc bearsays %} Yeah! And you see the definition of
      <code>takes_u64</code>? It has <code>val: u64</code>. {% endsc %}
    </p>
    <p>Yeah I see, I wrote it!</p>
    <p>
      {% sc bearsays %} So that means the compiler <em>knows</em> that the
      argument to <code>takes_u64</code> must be a <code>u64</code>, right? {%
      endsc %}
    </p>
    <p>Yeah?</p>
    <p>{% sc bearsays %} So it should be able to infer it! {% endsc %}</p>
    <p>Yeah, this does work:</p>
    <pre><code class="language-rust">    takes_u64(230984423857928735);
</code></pre>
    <p>
      {% sc bearsays %} Exactly! Whereas before, it defaulted to the type of the
      literal to <code>i32</code>, this time it knows it should be a
      <code>u64</code> in the end, so it turns the kind of squishy
      <code>{integer}</code> type into the very concrete <code>u64</code> type.
      {% endsc %}
    </p>
    <p>Neat.</p>
    <p>
      {% sc bearsays %} But it doesn't stop there — in a bunch of places in
      Rust, when you want to ask the compiler to &quot;just figure it out&quot;,
      you can substitute <code>_</code>. {% endsc %}
    </p>
    <p>No... so you mean?</p>
    <pre><code class="language-rust">fn main() {
    let val = 280_u32;
    takes_u32(val);
    //              👇
    takes_u64(val as _);
}

// etc.
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
[src/main.rs:8] val = 280
[src/main.rs:12] val = 280
</code></pre>
    <p>Neat!</p>
    <p>
      Let's try <code>.into()</code> too, since that's what the compiler
      suggested:
    </p>
    <pre><code class="language-rust">fn main() {
    let val = 280_u32;
    takes_u32(val);
    takes_u64(val.into());
}

// etc.
</code></pre>
    <p>That works too!</p>
    <p>{% sc bearsays %} Oooh, ooh, try it the other way around! {% endsc %}</p>
    <p>Like this?</p>
    <pre><code class="language-rust">fn main() {
    //             👇
    let val = 280_u64;
    //    👇
    takes_u64(val);
    //    👇
    takes_u32(val.into());
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
error[E0277]: the trait bound `u32: From&lt;u64&gt;` is not satisfied
 --&gt; src/main.rs:4:19
  |
4 |     takes_u32(val.into());
  |                   ^^^^ the trait `From&lt;u64&gt;` is not implemented for `u32`
  |
  = help: the following implementations were found:
            &lt;u32 as From&lt;Ipv4Addr&gt;&gt;
            &lt;u32 as From&lt;NonZeroU32&gt;&gt;
            &lt;u32 as From&lt;bool&gt;&gt;
            &lt;u32 as From&lt;char&gt;&gt;
          and 71 others
  = note: required because of the requirements on the impl of `Into&lt;u32&gt;` for `u64`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `grr` due to previous error
</code></pre>
    <p>
      Oh, it's not happy at all. It does helpfully suggest we could use an IPv4
      address instead, which...
    </p>
    <p>
      {% sc bearsays %} I know <em>someone</em> who'll think this diagnostic
      could use a little tune-up... {% endsc %}
    </p>
    <p>No no, we can try it, we got time:</p>
    <pre><code class="language-rust">use std::{net::Ipv4Addr, str::FromStr};

fn main() {
    takes_u32(Ipv4Addr::from_str(&quot;127.0.0.1&quot;).unwrap().into());
}

fn takes_u32(val: u32) {
    dbg!(val);
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
[src/main.rs:8] val = 2130706433
</code></pre>
    <p>...yes, okay.</p>
    <p>
      Just like an IPv6 address <em>can</em> be a <code>u128</code>, if it
      believes:
    </p>
    <pre><code class="language-rust">use std::{net::Ipv6Addr, str::FromStr};

fn main() {
    takes_u128(Ipv6Addr::from_str(&quot;ff::d1:e3&quot;).unwrap().into());
}

fn takes_u128(val: u128) {
    dbg!(val);
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
[src/main.rs:8] val = 1324035698926381045275276563964821731
</code></pre>
    <p>But apparently a <code>u64</code> can't be a <code>u32</code>?</p>
    <p>
      {% sc bearsays %} Well... that's because not <em>all</em> values of type
      <code>u64</code> fit into a <code>u32</code>. {% endsc %}
    </p>
    <p>Oh!</p>
    <p>
      {% sc bearsays %} ...that's why there's no
      <code>impl From&lt;u64&gt; for u32</code>... {% endsc %}
    </p>
    <p>Ah.</p>
    <p>
      {% sc bearsays %} ...but there <em>is</em> an
      <code>impl TryFrom&lt;u64&gt; for u32</code>. {% endsc %}
    </p>
    <p>Ah?</p>
    <p>
      {% sc bearsays %} Because <em>some</em> <code>u64</code> fit in a
      <code>u32</code>. {% endsc %}
    </p>
    <p>
      So err... we used <code>.into()</code> earlier... which we could do
      because... <code>From</code>?
    </p>
    <p>
      And so because now we have <code>TryFrom</code>...
      <code>.try_into()</code>?
    </p>
    <p>
      {% sc bearsays %} Yes! Because of
      <a
        href="https://doc.rust-lang.org/stable/std/convert/trait.Into.html#impl-Into%3CU%3E"
        >this blanket impl</a
      >
      and
      <a
        href="https://doc.rust-lang.org/stable/std/convert/trait.TryInto.html#impl-TryInto%3CU%3E"
        >that blanket impl</a
      >, respectively. {% endsc %}
    </p>
    <p>
      I have a feeling we'll come back to these later... but for now, let's give
      it a shot:
    </p>
    <pre><code class="language-rust">fn main() {
    let val: u64 = 48_000;
    takes_u32(val.try_into().unwrap());
}

fn takes_u32(val: u32) {
    dbg!(val);
}
</code></pre>
    <p>This compiles, and runs.</p>
    <p>As for this:</p>
    <pre><code class="language-rust">fn main() {
    let val: u64 = 25038759283948;
    takes_u32(val.try_into().unwrap());
}
</code></pre>
    <p>It compiles, but does not run!</p>
    <pre><code class="language-shell">$ cargo run --quiet
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: TryFromIntError(())', src/main.rs:3:30
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
    <p>Makes sense so far.</p>
    <p>And that's... that's all of it right?</p>
    <p>
      {% sc bearsays %} Not quite! You can <em>parse</em> stuff. {% endsc %}
    </p>
    <p>Ah, like we just did with <code>Ipv4Addr::from_str</code> right?</p>
    <p>
      {% sc bearsays %} Yes! But just like <code>T::from(val)</code> has
      <code>val.into()</code>, <code>T::from_str(val)</code> has
      <code>val.parse()</code>. {% endsc %}
    </p>
    <p>Fantastic! Let's give it a go:</p>
    <pre><code class="language-rust">fn main() {
    let val = &quot;1234&quot;.parse();
    dbg!(val);
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
error[E0284]: type annotations needed for `Result&lt;F, _&gt;`
 --&gt; src/main.rs:2:22
  |
2 |     let val = &quot;1234&quot;.parse();
  |         ---          ^^^^^ cannot infer type for type parameter `F` declared on the associated function `parse`
  |         |
  |         consider giving `val` the explicit type `Result&lt;F, _&gt;`, where the type parameter `F` is specified
  |
  = note: cannot satisfy `&lt;_ as FromStr&gt;::Err == _`

For more information about this error, try `rustc --explain E0284`.
error: could not compile `grr` due to previous error
</code></pre>
    <p>Oh it's... unhappy? Again?</p>
    <p>
      {% sc bearsays %} Consider this: what do you want to parse <em>to</em>? {%
      endsc %}
    </p>
    <p>A number, clearly! The string is <code>1234</code>.</p>
    <p>See, ECMAScript gets it right:</p>
    <pre><code class="language-javascript">let a = &quot;1234&quot;;
console.log({ a });
let b = parseInt(a, 10);
console.log({ b });
</code></pre>
    <pre><code class="language-shell">$ node main.js
{ a: '1234' }
{ b: 1234 }
</code></pre>
    <p>
      {% sc bearsays %} Nnnnonono, you said <code>parseInt</code>, not just
      <code>parse</code>. {% endsc %}
    </p>
    <p>Okay fine, let's not say <code>parse</code> at all then:</p>
    <pre><code class="language-javascript">let a = &quot;1234&quot;;
console.log({ a });
let b = +a;
console.log({ b });
</code></pre>
    <pre><code class="language-shell">$ node main.js
{ a: '1234' }
{ b: 1234 }
</code></pre>
    <p>
      {% sc bearsays %} Okay but the unary plus operator here <em>coerces</em> a
      <code>string</code> to a <code>number</code>, and in that case the only
      sensible thing to do is... {% endsc %}
    </p>
    <p>
      Nah nah nah, that's too easy. I think you're just looking for excuses. The
      truth is, ECMAScript is production-ready in a way that Rust isn't, and
      never will be.
    </p>
    <p>
      Those fools at work have it coming. Soon they'll realize! They've been
      had. They've been swindled. They've developed a taste for snake o-
    </p>
    <p>
      {% sc bearsays %} JUST ADD <code>: u64</code> AFTER
      <code>let val</code> WILL YOU {% endsc %}
    </p>
    <pre><code class="language-rust">fn main() {
    let val: u64 = &quot;2930482035982309&quot;.parse().unwrap();
    dbg!(val);
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
[src/main.rs:3] val = 2930482035982309
</code></pre>
    <p>Oh.</p>
    <p>
      Yeah that tracks. And I suppose if we have to care about bit widths here,
      that if I change it for <code>u32</code>...
    </p>
    <pre><code class="language-rust">fn main() {
    let val: u32 = &quot;2930482035982309&quot;.parse().unwrap();
    dbg!(val);
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: ParseIntError { kind: PosOverflow }', src/main.rs:2:47
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
    <p>It errors out, because that doesn't fit in a <code>u32</code>. I see.</p>
    <p>
      {% sc bearsays %} YES. NOW TRY CASTING THAT VALUE AS AN
      <code>u64</code> TO A <code>u32</code>. {% endsc %}
    </p>
    <p>Cool down, bear! I'll try, I'll try:</p>
    <pre><code class="language-rust">fn main() {
    let a = 2930482035982309_u64;
    println!(&quot;a = {a} (u64)&quot;);

    let b = a as u32;
    println!(&quot;b = {b} (u32)&quot;);
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
a = 2930482035982309 (u64)
b = 80117733 (u32)
</code></pre>
    <p>Oh. It's... it's not crashing, just... doing the wrong thing?</p>
    <p>{% sc bearsays %} YES THAT WAS MY POINT THANK YOU {% endsc %}</p>
    <p>
      Yeesh okay how about you take a minute there, bear. So I agree that number
      shouldn't fit in a <code>u32</code>, so it's doing... something with it.
    </p>
    <p>Maybe if we print it as hex:</p>
    <pre><code class="language-rust">fn main() {
    let a = 2930482035982309_u64;
    println!(&quot;a = {a:016x} (u64)&quot;);

    let b = a as u32;
    println!(&quot;b = {b:016x} (u32)&quot;);
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
a = 000a694204c67fe5 (u64)
b = 0000000004c67fe5 (u32)
            👆
</code></pre>
    <p>Oh yeah okay! It's truncating it!</p>
    <p>It's even clearer in binary:</p>
    <pre><code class="language-rust">fn main() {
    let a = 2930482035982309_u64;
    println!(&quot;a = {a:064b} (u64)&quot;);

    let b = a as u32;
    println!(&quot;b = {b:064b} (u32)&quot;);
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
a = 0000000000001010011010010100001000000100110001100111111111100101 (u64)
b = 0000000000000000000000000000000000000100110001100111111111100101 (u32)
                                   👆
</code></pre>
    <p>
      {% sc bearsays %} YES THAT'S THE PROBLEM WITH <code>as</code>. YOU CAN
      TRUNCATE VALUES WHEN YOU DIDN'T INTEND TO. {% endsc %}
    </p>
    <p>Ah. But it's shorter and super convenient still, right?</p>
    <p>{% sc bearsays %} I GUESS! {% endsc %}</p>
    <p>Gotcha.</p>
    <h2>Generics and enums</h2>
    <p>
      {% sc bearsays %} Wait wait wait, we haven't even talked about strings
      yet. Are you sure about that heading? {% endsc %}
    </p>
    <p>
      Hell yeah! Generics are baby stuff: you just slap a couple angle brackets,
      or &quot;chevrons&quot; if you want to be fancy, and boom, Bob's your
      uncle!
    </p>
    <p>{% sc bearsays %} Ew. {% endsc %}</p>
    <p>{% sc amossays %} Not <em>that</em> Bob. {% endsc %}</p>
    <p>See, this for example:</p>
    <pre><code class="language-rust">fn show&lt;T&gt;(a: T) {
    todo!()
}
</code></pre>
    <p>
      Now we can call it with a value <code>a</code> of type <code>T</code>, for
      any <code>T</code>!
    </p>
    <pre><code class="language-rust">fn main() {
    show(42);
    show(&quot;blah&quot;);
}
</code></pre>
    <p>
      {% sc bearsays %} Okay yeah but you haven't implemented it yet! {% endsc
      %}
    </p>
    <p>True true, it panics right now:</p>
    <pre><code class="language-shell">$ cargo run --quiet
thread 'main' panicked at 'not yet implemented', src/main.rs:7:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
    <p>But we could... I don't know, we could display it!</p>
    <pre><code class="language-rust">fn main() {
    show(42);
    show(&quot;blah&quot;);
}

fn show&lt;T&gt;(a: T) {
    println!(&quot;a = {}&quot;, a);
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
error[E0277]: `T` doesn't implement `std::fmt::Display`
 --&gt; src/main.rs:7:24
  |
7 |     println!(&quot;a = {}&quot;, a);
  |                        ^ `T` cannot be formatted with the default formatter
  |
  = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
  = note: this error originates in the macro `$crate::format_args_nl` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider restricting type parameter `T`
  |
6 | fn show&lt;T: std::fmt::Display&gt;(a: T) {
  |          +++++++++++++++++++

For more information about this error, try `rustc --explain E0277`.
error: could not compile `grr` due to previous error
</code></pre>
    <p>Mhhhhhh. Does not implement <code>Display</code>.</p>
    <p>Okay maybe <code>{:?}</code> instead of <code>{}</code> then?</p>
    <pre><code class="language-rust">fn show&lt;T&gt;(a: T) {
    println!(&quot;a = {:?}&quot;, a);
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
error[E0277]: `T` doesn't implement `Debug`
 --&gt; src/main.rs:7:26
  |
7 |     println!(&quot;a = {:?}&quot;, a);
  |                          ^ `T` cannot be formatted using `{:?}` because it doesn't implement `Debug`
  |
  = note: this error originates in the macro `$crate::format_args_nl` (in Nightly builds, run with -Z macro-backtrace for more info)
help: consider restricting type parameter `T`
  |
6 | fn show&lt;T: std::fmt::Debug&gt;(a: T) {
  |          +++++++++++++++++

For more information about this error, try `rustc --explain E0277`.
error: could not compile `grr` due to previous error
</code></pre>
    <p>Oh now it doesn't implement <code>Debug</code>.</p>
    <p>
      Well. Okay! Maybe <code>show</code> can't do anything useful with its
      argument, but at least you can pass <em>any type</em> to it.
    </p>
    <p>And, because <code>T</code> is a type like any other...</p>
    <p>
      {% sc bearsays %} A &quot;type parameter&quot;, technically, but who's
      keeping track. {% endsc %}
    </p>
    <p>...you can use it several times, probably!</p>
    <pre><code class="language-rust">fn main() {
    show(5, 7);
    show(&quot;blah&quot;, &quot;bleh&quot;);
}

fn show&lt;T&gt;(a: T, b: T) {
    todo!()
}
</code></pre>
    <p>Yeah, see, that works!</p>
    <p>And if we do this:</p>
    <pre><code class="language-rust">fn main() {
    show(42, &quot;aha&quot;)
}

fn show&lt;T&gt;(a: T, b: T) {
    todo!()
}
</code></pre>
    <p>It... oh.</p>
    <pre><code class="language-shell">$ cargo run --quiet
error[E0308]: mismatched types
 --&gt; src/main.rs:2:14
  |
2 |     show(42, &quot;aha&quot;)
  |              ^^^^^ expected integer, found `&amp;str`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `grr` due to previous error
</code></pre>
    <p>
      Well that's interesting. I guess they have to match? So like it's using
      the first argument, <code>42</code>, to infer <code>T</code>, and then the
      second one has to match, alright.
    </p>
    <p>
      {% sc bearsays %} Yeah, and you'll notice it says &quot;expected
      integer&quot;, not &quot;expected i32&quot;. {% endsc %}
    </p>
    <p>So that means this would work:</p>
    <pre><code class="language-rust">    show(42, 256_u64)
</code></pre>
    <p>And it does!</p>
    <p>
      And if we want two genuinely different types, I guess we have to... use
      two dif-
    </p>
    <p>{% sc bearsays %} Use two different type parameters, yes. {% endsc %}</p>
    <pre><code class="language-rust">fn main() {
    show(4, &quot;hi&quot;)
}

fn show&lt;A, B&gt;(a: A, b: B) {
    todo!()
}
</code></pre>
    <p>That works! Alright.</p>
    <p>
      Well we don't know how to do anything useful with these values yet, but-
    </p>
    <p>{% sc bearsays %} Yes, that's what you get for trying to skip ahead.</p>
    <p>How about a nice enum instead? {% endsc %}</p>
    <p>Something like this?</p>
    <pre><code class="language-rust">fn main() {
    show(Answer::Maybe)
}

enum Answer {
    Yes,
    No,
    Maybe,
}

fn show(answer: Answer) {
    let s = match answer {
        Answer::Yes =&gt; &quot;yes&quot;,
        Answer::No =&gt; &quot;no&quot;,
        Answer::Maybe =&gt; &quot;maybe&quot;,
    };
    println!(&quot;the answer is {s}&quot;);
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
the answer is maybe
</code></pre>
    <p>
      {% sc bearsays %} I mean, yeah sure. That's a good starting point. {%
      endsc %}
    </p>
    <p>And maybe you want me to learn about this, too?</p>
    <pre><code class="language-rust">fn is_yes(answer: Answer) -&gt; bool {
    if let Answer::Yes = answer {
        true
    } else {
        false
    }
}
</code></pre>
    <p>{% sc bearsays %} Sure, but mostly I w- {% endsc %}</p>
    <p>Or better still, this?</p>
    <pre><code class="language-rust">fn is_yes(answer: Answer) -&gt; bool {
    matches!(answer, Answer::Yes)
}
</code></pre>
    <p>{% sc bearsays %} No, more like this: {% endsc %}</p>
    <pre><code class="language-rust">fn main() {
    show(Either::Character('C'));
    show(Either::Number(64));
}

enum Either {
    Number(i64),
    Character(char),
}

fn show(either: Either) {
    match either {
        Either::Number(n) =&gt; println!(&quot;{n}&quot;),
        Either::Character(c) =&gt; println!(&quot;{c}&quot;),
    }
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
C
64
</code></pre>
    <p>
      Oh, yeah, that's pretty good. So like enum variants that... hold some
      data?
    </p>
    <p>{% sc bearsays %} Yes! {% endsc %}</p>
    <p>
      And you can do pattern matching to know which variant it is, and to access
      what's inside.
    </p>
    <p>
      And I suppose it's safe too, as in it won't let you accidentally access
      the wrong variant?
    </p>
    <p>
      {% sc bearsays %} Yes, yes of course. These are no C unions. They're
      <a href="https://en.wikipedia.org/wiki/Tagged_union">tagged unions</a>. Or
      choice types. Or sum types. Or coproducts. {% endsc %}
    </p>
    <p>Let's just stick with &quot;enums&quot;.</p>
    <p>
      But that's great news: I can finally take functions that can handle
      multiple types, even without understanding generics!
    </p>
    <p>
      And I suppose... conversions could help there too? Like what if I could do
      this?
    </p>
    <pre><code class="language-rust">fn main() {
    show('C'.into());
    show(64.into());
}
</code></pre>
    <p>
      {% sc bearsays %} Sure, you can do that. Just implement a couple traits!
      {% endsc %}
    </p>
    <p>Traits? But we're in the enums sect-</p>
    <h2>Implementing traits</h2>
    <p>Ah, here we are. Couple traits, okay, show me!</p>
    <pre><code class="language-rust">fn main() {
    show('C'.into());
    show(64.into());
}

enum Either {
    Number(i64),
    Character(char),
}

//        👇
impl From&lt;i64&gt; for Either {
    fn from(n: i64) -&gt; Self {
        Either::Number(n)
    }
}

//        👇
impl From&lt;char&gt; for Either {
    fn from(c: char) -&gt; Self {
        Either::Character(c)
    }
}

fn show(either: Either) {
    match either {
        Either::Number(n) =&gt; println!(&quot;{n}&quot;),
        Either::Character(c) =&gt; println!(&quot;{c}&quot;),
    }
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
C
64
</code></pre>
    <p>
      Hey, that's pretty good! But we haven't declared that
      <code>From</code> trait anywhere, let's see... ah, here's what it looks
      like, from the Rust standard library:
    </p>
    <pre><code class="language-rust">pub trait From&lt;T&gt; {
    fn from(T) -&gt; Self;
}
</code></pre>
    <p>Ah, that's refreshingly short. And <code>Self</code> is?</p>
    <p>
      {% sc bearsays %} The type you're implementing
      <code>From&lt;T&gt;</code> for. {% endsc %}
    </p>
    <p>And then I suppose <code>Into</code> is also in there somewhere?</p>
    <pre><code class="language-rust">pub trait Into&lt;T&gt; {
  fn into(self) -&gt; T;
}
</code></pre>
    <p>Right! And <code>self</code> is...</p>
    <p>
      {% sc bearsays %} ...short for <code>self: Self</code>, in that position.
      {% endsc %}
    </p>
    <p>And I suppose there's other traits?</p>
    <p>Wait, are <code>Display</code> and <code>Debug</code> traits?</p>
    <p>
      {% sc bearsays %} They are! Here, let me show you something: {% endsc %}
    </p>
    <pre><code class="language-rust">use std::fmt::Display;

fn main() {
    show(&amp;'C');
    show(&amp;64);
}

fn show(v: &amp;dyn Display) {
    println!(&quot;{v}&quot;);
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
C
64
</code></pre>
    <p>
      Whoa. WHOA. Game changer. No <code>.into()</code> needed, it just works?
      Very cool.
    </p>
    <p>{% sc bearsays %} Now let me show you something else: {% endsc %}</p>
    <pre><code class="language-rust">use std::fmt::Display;

fn main() {
    show(&amp;'C');
    show(&amp;64);
}

fn show(v: impl Display) {
    println!(&quot;{v}&quot;);
}
</code></pre>
    <p>
      That works too? No way! <code>v</code> can be whichever type implements
      <code>Display</code>! So nice!
    </p>
    <p>
      {% sc bearsays %} Yes! It's the shorter way of spelling this: {% endsc %}
    </p>
    <pre><code class="language-rust">fn show&lt;D: Display&gt;(v: D) {
    println!(&quot;{v}&quot;);
}
</code></pre>
    <p>
      Ah!!! So that's how you add a... how you tell the compiler that the type
      must implement something.
    </p>
    <p>
      {% sc bearsays %} A trait bound, yes. There's an even longer way to spell
      this: {% endsc %}
    </p>
    <pre><code class="language-rust">fn show&lt;D&gt;(v: D)
where
    D: Display,
{
    println!(&quot;{v}&quot;);
}
</code></pre>
    <p>
      Okay, that... I mean if you ignore all the punctuation going on, this
      almost reads like English. If English were maths. Well, the kind of maths
      compilers think about. Possibly
      <a href="https://en.wikipedia.org/wiki/Type_theory">type theory</a>?
    </p>
    <h2>Return position</h2>
    <p>Wait, I didn't type that heading. Cool bear??</p>
    <p>{% sc bearsays %} Shh, look at this. {% endsc %}</p>
    <pre><code class="language-rust">use std::fmt::Display;

fn main() {
    show(get_char());
    show(get_int());
}

fn get_char() -&gt; impl Display {
    'C'
}

fn get_int() -&gt; impl Display {
    64
}

fn show(v: impl Display) {
    println!(&quot;{v}&quot;);
}
</code></pre>
    <p>
      Okay. So we can use <code>impl Display</code> &quot;in return
      position&quot;, if we don't feel like typing it all out. That's good.
    </p>
    <p>
      And I suppose, since <code>impl T</code> is much like generics, we can
      probably do something like:
    </p>
    <pre><code class="language-rust">use std::fmt::Display;

fn main() {
    show(get_char_or_int(true));
    show(get_char_or_int(false));
}

fn get_char_or_int(give_char: bool) -&gt; impl Display {
    if give_char {
        'C'
    } else {
        64
    }
}

fn show(v: impl Display) {
    println!(&quot;{v}&quot;);
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
error[E0308]: `if` and `else` have incompatible types
  --&gt; src/main.rs:12:9
   |
9  | /     if give_char {
10 | |         'C'
   | |         --- expected because of this
11 | |     } else {
12 | |         64
   | |         ^^ expected `char`, found integer
13 | |     }
   | |_____- `if` and `else` have incompatible types

For more information about this error, try `rustc --explain E0308`.
error: could not compile `grr` due to previous error
</code></pre>
    <p>Ah. No I cannot.</p>
    <p>
      So our return type is <code>impl Display</code>... ah, and it infers it to
      be <code>char</code>, because that's the first thing we return! And so the
      other thing must also be <code>char</code>.
    </p>
    <p>But it's not.</p>
    <p>Well I'm lost. Bear, how do we get out of this?</p>
    <p>Bear?</p>
    <p>...okay maybe... generics? 🤷</p>
    <pre><code class="language-rust">fn get_char_or_int&lt;D: Display&gt;(give_char: bool) -&gt; D {
    if give_char {
        'C'
    } else {
        64
    }
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
error[E0282]: type annotations needed
 --&gt; src/main.rs:4:5
  |
4 |     show(get_char_or_int(true));
  |     ^^^^ cannot infer type for type parameter `impl Display` declared on the function `show`

error[E0308]: mismatched types
  --&gt; src/main.rs:10:9
   |
8  | fn get_char_or_int&lt;D: Display&gt;(give_char: bool) -&gt; D {
   |                    -                               -
   |                    |                               |
   |                    |                               expected `D` because of return type
   |                    this type parameter             help: consider using an impl return type: `impl Display`
9  |     if give_char {
10 |         'C'
   |         ^^^ expected type parameter `D`, found `char`
   |
   = note: expected type parameter `D`
                        found type `char`

error[E0308]: mismatched types
  --&gt; src/main.rs:12:9
   |
8  | fn get_char_or_int&lt;D: Display&gt;(give_char: bool) -&gt; D {
   |                    -                               -
   |                    |                               |
   |                    |                               expected `D` because of return type
   |                    this type parameter             help: consider using an impl return type: `impl Display`
...
12 |         64
   |         ^^ expected type parameter `D`, found integer
   |
   = note: expected type parameter `D`
                        found type `{integer}`

Some errors have detailed explanations: E0282, E0308.
For more information about an error, try `rustc --explain E0282`.
error: could not compile `grr` due to 3 previous errors
</code></pre>
    <p>Err, ew, no, go back, that's even worse.</p>
    <p>{% sc bearsays %} Yeah that'll never work. {% endsc %}</p>
    <p>Bear where were you!</p>
    <p>{% sc bearsays %} Bear business. You wouldn't get it. {% endsc %}</p>
    <p>I...</p>
    <p>
      {% sc bearsays %} It'll never work, but the compiler's got your back: it
      tells you you should be using <code>impl Display</code>. {% endsc %}
    </p>
    <p>But that's what I tried first!</p>
    <p>
      {% sc bearsays %} Okay well, the <code>impl Display</code> in question can
      only be a single type. {% endsc %}
    </p>
    <p>But then what good is it?</p>
    <p>
      {% sc bearsays %} Okay let's back up. You remember how you made an enum to
      handle arguments of two different types? {% endsc %}
    </p>
    <p>Vaguely? Oh I can do that here too, can't I.</p>
    <p>Let's see 🎶</p>
    <pre><code class="language-rust">use std::fmt::Display;

fn main() {
    show(get_char_or_int(true));
    show(get_char_or_int(false));
}

enum Either {
    Char(char),
    Int(i64),
}

fn get_char_or_int(give_char: bool) -&gt; Either {
    if give_char {
        Either::Char('C')
    } else {
        Either::Int(64)
    }
}

fn show(v: impl Display) {
    println!(&quot;{v}&quot;);
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
error[E0277]: `Either` doesn't implement `std::fmt::Display`
  --&gt; src/main.rs:4:10
   |
4  |     show(get_char_or_int(true));
   |     ---- ^^^^^^^^^^^^^^^^^^^^^ `Either` cannot be formatted with the default formatter
   |     |
   |     required by a bound introduced by this call
   |
   = help: the trait `std::fmt::Display` is not implemented for `Either`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
note: required by a bound in `show`
  --&gt; src/main.rs:21:17
   |
21 | fn show(v: impl Display) {
   |                 ^^^^^^^ required by this bound in `show`

error[E0277]: `Either` doesn't implement `std::fmt::Display`
  --&gt; src/main.rs:5:10
   |
5  |     show(get_char_or_int(false));
   |     ---- ^^^^^^^^^^^^^^^^^^^^^^ `Either` cannot be formatted with the default formatter
   |     |
   |     required by a bound introduced by this call
   |
   = help: the trait `std::fmt::Display` is not implemented for `Either`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
note: required by a bound in `show`
  --&gt; src/main.rs:21:17
   |
21 | fn show(v: impl Display) {
   |                 ^^^^^^^ required by this bound in `show`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `grr` due to 2 previous errors
</code></pre>
    <p>
      Oh, wait, wait, I know this! I can just implement <code>Display</code> for
      <code>Either</code>:
    </p>
    <pre><code class="language-rust">impl Display for Either {
  // ...
}
</code></pre>
    <p>Wait, what do I put in there?</p>
    <p>
      {% sc bearsays %} Use the
      <a href="https://rust-analyzer.github.io/">rust-analyzer</a> code
      generation assist.
    </p>
    <p>You do have it installed, right? {% endsc %}</p>
    <p>
      Yes haha, of course, yes. Okay so <code>Ctrl+.</code> (<code>Cmd+.</code>
      on macOS), pick &quot;Implement missing members&quot;, and... it gives me
      this:
    </p>
    <pre><code class="language-rust">impl Display for Either {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        todo!()
    }
}
</code></pre>
    <p>
      ...and then I guess I just match on <code>self</code>? To call either the
      <code>Display</code> implementation for <code>char</code> or for
      <code>i64</code>?
    </p>
    <pre><code class="language-rust">impl Display for Either {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        match self {
            //
        }
    }
}
</code></pre>
    <p>Wait, what do I write there?</p>
    <p>
      {% sc bearsays %} Use the
      <a href="https://rust-analyzer.github.io/">rust-analyzer</a> code
      generation assist. {% endsc %}
    </p>
    <p>Sounding like a broken record, you doing ok bear?</p>
    <p>
      {% sc bearsays %} I am. There's a different code generation assist for
      this. Alternatively,
      <a href="https://copilot.github.com/">GitHub Copilot</a> might write the
      whole block for you.
    </p>
    <p>It's getting better. It's <em>learning</em>. {% endsc %}</p>
    <p>Okay, using the &quot;Fill match arms&quot; assist...</p>
    <pre><code class="language-rust">impl Display for Either {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        match self {
            Either::Char(_) =&gt; todo!(),
            Either::Int(_) =&gt; todo!(),
        }
    }
}
</code></pre>
    <p>Okay I can do the rest!</p>
    <pre><code class="language-rust">impl Display for Either {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        match self {
            Either::Char(c) =&gt; c.fmt(f),
            Either::Int(i) =&gt; i.fmt(f),
        }
    }
}
</code></pre>
    <p>And this now runs!</p>
    <pre><code class="language-shell">$ cargo run --quiet
C
64
</code></pre>
    <p>Nice. But that was, like, super verbose. Can we make it less verbose?</p>
    <p>
      {% sc bearsays %} Sure! You can use the
      <a href="https://lib.rs/crates/delegate">delegate</a> crate, for instance.
      {% endsc %}
    </p>
    <p>Okay okay I remember that bit, so you just:</p>
    <pre><code class="language-shell">$ cargo add delegate
    Updating 'https://github.com/rust-lang/crates.io-index' index
      Adding delegate v0.6.2 to dependencies.
</code></pre>
    <p>And then... wait, what do we delegate to?</p>
    <p>{% sc bearsays %} Oh I'll give you this one for free: {% endsc %}</p>
    <pre><code class="language-rust">impl Either {
    fn display(&amp;self) -&gt; &amp;dyn Display {
        match self {
            Either::Char(c) =&gt; c,
            Either::Int(i) =&gt; i,
        }
    }
}
</code></pre>
    <p>
      Wait wait wait but that's interesting as heck. You don't need traits to
      add methods to types like that? You can <em>return</em> a
      <code>&amp;dyn Trait</code> object? That borrows from
      <code>&amp;self</code>? Which is short for <code>self: &amp;Self</code>?
      And it extends the lifetime of the receiver, also called a
      borrow-through???
    </p>
    <p>
      {% sc bearsays %} Heyyyyyyyyy now where did you learn all that, we covered
      nothing of this. {% endsc %}
    </p>
    <p>
      <a href="/articles/a-rust-match-made-in-hell">Hehehe</a> okay forget about
      it.
    </p>
    <p>
      Okay so now that we've got a <code>display</code> method we can do this:
    </p>
    <pre><code class="language-rust">impl Display for Either {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        self.display().fmt(f)
    }
}
</code></pre>
    <p>
      And that's where the
      <a href="https://lib.rs/crates/delegate">delegate</a> crate comes in to
      make things simpler (or at least shorter), mhh, looking at the README, we
      can probably do...
    </p>
    <pre><code class="language-rust">impl Display for Either {
    delegate::delegate! {
        to self.display() {
            fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result;
        }
    }
}
</code></pre>
    <p>
      {% sc bearsays %} Yeah! Or, you know,
      <code>use delegate::delegate;</code> first, and then you can just call the
      macro with <code>delegate!</code> instead of <em>qualifying</em> it with
      <code>delegate::delegate!</code>.
    </p>
    <p>
      There's even a rust-analyzer assist for it — &quot;replace qualified path
      with use&quot;. {% endsc %}
    </p>
    <p>Macros? Qualified paths? Wow, we're glossing over a lot of things.</p>
    <p>{% sc bearsays %} Not <em>that many</em>, but yes. {% endsc %}</p>
    <p>Anyway, that all works! Here's the complete listing:</p>
    <pre><code class="language-rust">use delegate::delegate;
use std::fmt::Display;

fn main() {
    show(get_char_or_int(true));
    show(get_char_or_int(false));
}

impl Either {
    fn display(&amp;self) -&gt; &amp;dyn Display {
        match self {
            Either::Char(c) =&gt; c,
            Either::Int(i) =&gt; i,
        }
    }
}

impl Display for Either {
    delegate! {
        to self.display() {
            fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result;
        }
    }
}

enum Either {
    Char(char),
    Int(i64),
}

fn get_char_or_int(give_char: bool) -&gt; Either {
    if give_char {
        Either::Char('C')
    } else {
        Either::Int(64)
    }
}

fn show(v: impl Display) {
    println!(&quot;{v}&quot;);
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
C
64
</code></pre>
    <p>
      But... it feels a little wrong to have to write all that code just to do
      that.
    </p>
    <p>{% sc bearsays %} Ah, that's because you don't! {% endsc %}</p>
    <h2>Dynamically-sized types</h2>
    <p>Uhhh. What does any of that mean?</p>
    <p>
      {% sc bearsays %} Okay, so it's more implementation details: just like bit
      widths (<code>u32</code> vs <code>u64</code>), etc. But details are where
      the devil vacations.
    </p>
    <p>
      Try printing the size of a few things with
      <a href="https://doc.rust-lang.org/stable/std/mem/fn.size_of.html"
        >std::mem::size_of</a
      >. {% endsc %}
    </p>
    <p>Okay then!</p>
    <pre><code class="language-rust">fn main() {
    dbg!(std::mem::size_of::&lt;u32&gt;());
    dbg!(std::mem::size_of::&lt;u64&gt;());
    dbg!(std::mem::size_of::&lt;u128&gt;());
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
[src/main.rs:2] std::mem::size_of::&lt;u32&gt;() = 4
[src/main.rs:3] std::mem::size_of::&lt;u64&gt;() = 8
[src/main.rs:4] std::mem::size_of::&lt;u128&gt;() = 16
</code></pre>
    <p>Okay, 32 bits is 4 bytes, that checks out on <code>x86_64</code>.</p>
    <p>{% sc bearsays %} Wait, where did you learn that syntax? {% endsc %}</p>
    <p>
      Ehh you showed it to me with <code>typeof</code> and, I looked it up:
      turns out it's named <a href="https://turbo.fish/">turbofish</a> syntax!
      The name was cute, so I remembered.
    </p>
    <p>{% sc bearsays %} Okay, now try references. {% endsc %}</p>
    <p>Sure!</p>
    <pre><code class="language-rust">fn main() {
    dbg!(std::mem::size_of::&lt;&amp;u32&gt;());
    dbg!(std::mem::size_of::&lt;&amp;u64&gt;());
    dbg!(std::mem::size_of::&lt;&amp;u128&gt;());
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
[src/main.rs:2] std::mem::size_of::&lt;&amp;u32&gt;() = 8
[src/main.rs:3] std::mem::size_of::&lt;&amp;u64&gt;() = 8
[src/main.rs:4] std::mem::size_of::&lt;&amp;u128&gt;() = 8
</code></pre>
    <p>
      Yeah, they're all 64-bit! Again, I'm on an x86_64 CPU right now, so that's
      not super surprising.
    </p>
    <p>{% sc bearsays %} Now try trait objects. {% endsc %}</p>
    <p>Oh, the <code>dyn Trait</code> stuff?</p>
    <pre><code class="language-rust">use std::fmt::Debug;

fn main() {
    dbg!(std::mem::size_of::&lt;dyn Debug&gt;());
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
error[E0277]: the size for values of type `dyn std::fmt::Debug` cannot be known at compilation time
   --&gt; src/main.rs:4:10
    |
4   |     dbg!(std::mem::size_of::&lt;dyn Debug&gt;());
    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
    |
    = help: the trait `Sized` is not implemented for `dyn std::fmt::Debug`
note: required by a bound in `std::mem::size_of`
   --&gt; /home/amos/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/mem/mod.rs:304:22
    |
304 | pub const fn size_of&lt;T&gt;() -&gt; usize {
    |                      ^ required by this bound in `std::mem::size_of`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `grr` due to previous error
</code></pre>
    <p>Oh. But that's... mhh.</p>
    <p>
      {% sc bearsays %} What type <em>is</em> <code>dyn Debug</code>? What size
      would you expect it to have? {% endsc %}
    </p>
    <p>
      I don't know, I suppose... I suppose a lot of types implement
      <code>Debug</code>? Like, <code>u32</code> does, <code>u64</code> does,
      <code>u128</code> does too, and <code>String</code>, and...
    </p>
    <p>
      {% sc bearsays %} Exactly. It could be any of these, and then some. So
      it's impossible to know what size it is, because
      <em>it could have any size</em>.
    </p>
    <p>
      Heck, even the empty tuple type, <code>()</code>, implements
      <code>Debug</code>! {% endsc %}
    </p>
    <pre><code class="language-rust">fn main() {
    dbg!(std::mem::size_of::&lt;()&gt;());
    println!(&quot;{:?}&quot;, ());
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
[src/main.rs:2] std::mem::size_of::&lt;()&gt;() = 0
()
</code></pre>
    <p>
      {% sc bearsays %} ...and it's a zero-sized type! (a ZST). So
      <code>dyn Debug</code>, or any other &quot;trait object&quot;, is a DST: a
      dynamically-sized type. {% endsc %}
    </p>
    <p>
      Wait, but we did return a <code>&amp;dyn Display</code> at some point,
      right?
    </p>
    <p>{% sc bearsays %} Ah, yes, but references al- {% endsc %}</p>
    <p>
      ...all have the same size! Right!!! Because you're not holding the actual
      value, you're just holding the address of it!
    </p>
    <p>{% sc bearsays %} Exactly! {% endsc %}</p>
    <pre><code class="language-rust">use std::mem::size_of_val;

fn main() {
    let a = 101_u128;
    println!(&quot;{:16}, of size {}&quot;, a, size_of_val(&amp;a));
    println!(&quot;{:16p}, of size {}&quot;, &amp;a, size_of_val(&amp;&amp;a));
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
             101, of size 16
  0x7ffdc4fb8af8, of size 8
</code></pre>
    <p>And so uh... what was that about us not needing the enum at all?</p>
    <p>{% sc bearsays %} We're getting to it! {% endsc %}</p>
    <h2>Storing stuff in structs</h2>
    <p>Oh structs, those are easy, just like other languages right?</p>
    <p>Like that:</p>
    <pre><code class="language-rust">#[derive(Debug)]
struct Vec2 {
    x: f64,
    y: f64,
}

fn main() {
    let v = Vec2 { x: 1.0, y: 2.0 };
    println!(&quot;v = {v:#?}&quot;);
}
</code></pre>
    <p>
      {% sc bearsays %} Wait, `#[derive(Debug)]? I don't find we've quite
      reached that part of the curriculum yet... in fact I don't see it in there
      at all. {% endsc %}
    </p>
    <p>
      Oh it's just a macro that can implement a trait for you, in this case it
      expands to something like this:
    </p>
    <pre><code class="language-rust">use std::fmt;

impl fmt::Debug for Vec2 {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        f.debug_struct(&quot;Vec2&quot;)
            .field(&quot;x&quot;, &amp;self.x)
            .field(&quot;y&quot;, &amp;self.y)
            .finish()
    }
}
</code></pre>
    <p>
      {% sc bearsays %} Well well well look who's teaching who now? {% endsc %}
    </p>
    <p>
      No it's types I'm struggling with, the rest is easy peasy limey squeezy.
    </p>
    <p>But not structs, structs are easy, this, my program runs:</p>
    <pre><code class="language-shell">$ cargo run --quiet
v = Vec2 {
    x: 1.0,
    y: 2.0,
}

</code></pre>
    <p>
      {% sc bearsays %} Okay, now make a function that adds two
      <code>Vec2</code>! {% endsc %}
    </p>
    <p>Alright!</p>
    <pre><code class="language-rust">#[derive(Debug)]
struct Vec2 {
    x: f64,
    y: f64,
}

impl Vec2 {
    fn add(self, other: Vec2) -&gt; Vec2 {
        Vec2 {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    let v = Vec2 { x: 1.0, y: 2.0 };
    let w = Vec2 { x: 9.0, y: 18.0 };
    dbg!(v.add(w));
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
[src/main.rs:21] v.add(w) = Vec2 {
    x: 10.0,
    y: 20.0,
}
</code></pre>
    <p>{% sc bearsays %} Now call add twice! {% endsc %}</p>
    <pre><code class="language-rust">fn main() {
    let v = Vec2 { x: 1.0, y: 2.0 };
    let w = Vec2 { x: 9.0, y: 18.0 };
    dbg!(v.add(w));
    dbg!(v.add(w));
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
error[E0382]: use of moved value: `v`
  --&gt; src/main.rs:22:10
   |
19 |     let v = Vec2 { x: 1.0, y: 2.0 };
   |         - move occurs because `v` has type `Vec2`, which does not implement the `Copy` trait
20 |     let w = Vec2 { x: 9.0, y: 18.0 };
21 |     dbg!(v.add(w));
   |            ------ `v` moved due to this method call
22 |     dbg!(v.add(w));
   |          ^ value used here after move
   |
note: this function takes ownership of the receiver `self`, which moves `v`
  --&gt; src/main.rs:10:12
   |
10 |     fn add(self, other: Vec2) -&gt; Vec2 {
   |            ^^^^

error[E0382]: use of moved value: `w`
  --&gt; src/main.rs:22:16
   |
20 |     let w = Vec2 { x: 9.0, y: 18.0 };
   |         - move occurs because `w` has type `Vec2`, which does not implement the `Copy` trait
21 |     dbg!(v.add(w));
   |                - value moved here
22 |     dbg!(v.add(w));
   |                ^ value used here after move

For more information about this error, try `rustc --explain E0382`.
error: could not compile `grr` due to 2 previous errors
</code></pre>
    <p>Erm, doesn't work.</p>
    <p>{% sc bearsays %} Do you know why? {% endsc %}</p>
    <p>
      I mean it says stuff? Something something <code>Vec2</code> does not
      implement <code>Copy</code>, yet more traits, okay, so it gets
      &quot;moved&quot;.
    </p>
    <p>Wait we can probably work around this with <code>Clone</code>!</p>
    <pre><code class="language-rust">//               👇
#[derive(Debug, Clone)]
struct Vec2 {
    x: f64,
    y: f64,
}

fn main() {
    let v = Vec2 { x: 1.0, y: 2.0 };
    let w = Vec2 { x: 9.0, y: 18.0 };
    dbg!(v.clone().add(w.clone()));
    dbg!(v.add(w));
}
</code></pre>
    <p>Okay it works again!</p>
    <p>
      {% sc bearsays %} What if you don't want to call <code>.clone()</code>? {%
      endsc %}
    </p>
    <p>Then I guess... <code>Copy</code>?</p>
    <pre><code class="language-rust">#[derive(Debug, Clone, Copy)]
struct Vec2 {
    x: f64,
    y: f64,
}

fn main() {
    let v = Vec2 { x: 1.0, y: 2.0 };
    let w = Vec2 { x: 9.0, y: 18.0 };
    dbg!(v.add(w));
    dbg!(v.add(w));
}
</code></pre>
    <p>
      {% sc bearsays %} Very good! Now forget about all that code, and tell me
      what's the type of &quot;hello world&quot;? {% endsc %}
    </p>
    <p>
      Ah, I'll just re-use the <code>type_name_of</code> function you gave me...
      one sec...
    </p>
    <pre><code class="language-rust">fn main() {
    dbg!(type_name_of(&quot;hello world&quot;));
}

fn type_name_of&lt;T&gt;(_: T) -&gt; &amp;'static str {
    std::any::type_name::&lt;T&gt;()
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
[src/main.rs:2] type_name_of(&quot;hello world&quot;) = &quot;&amp;str&quot;
</code></pre>
    <p>There it is! It's <code>&amp;str</code>!</p>
    <p>{% sc bearsays %} Alright! Now store it in a struct! {% endsc %}</p>
    <p>Sure, easy enough:</p>
    <pre><code class="language-rust">#[derive(Debug)]
struct Message {
    text: &amp;str,
}

fn main() {
    let msg = Message {
        text: &quot;hello world&quot;,
    };
    dbg!(msg);
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:3:11
  |
3 |     text: &amp;str,
  |           ^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
2 ~ struct Message&lt;'a&gt; {
3 ~     text: &amp;'a str,
  |

For more information about this error, try `rustc --explain E0106`.
error: could not compile `grr` due to previous error
</code></pre>
    <p>Oh. Not easy enough.</p>
    <p>
      {% sc bearsays %} The compiler is showing you the way — heed its advice!
      {% endsc %}
    </p>
    <p>Okay, sure:</p>
    <pre><code class="language-rust">#[derive(Debug)]
//             👇
struct Message&lt;'a&gt; {
//        👇
    text: &amp;'a str,
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
[src/main.rs:12] msg = Message {
    text: &quot;hello world&quot;,
}
</code></pre>
    <p>
      {% sc bearsays %} Okay, now read the file <code>src/main.rs</code> as a
      string, and store a reference to it in a <code>Message</code>. {% endsc %}
    </p>
    <p>
      Fine, fine, so, reading files...
      <a href="https://doc.rust-lang.org/stable/std/fs/index.html">std::fs</a>
      perhaps?
    </p>
    <pre><code class="language-rust">fn main() {
    let code = std::fs::read_to_string(&quot;src/main.rs&quot;).unwrap();
    let msg = Message { text: &amp;code };
    dbg!(msg);
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
[src/main.rs:9] msg = Message {
    text: &quot;#[derive(Debug)]\nstruct Message&lt;'a&gt; {\n    text: &amp;'a str,\n}\n\nfn main() {\n    let code = std::fs::read_to_string(\&quot;src/main.rs\&quot;).unwrap();\n    let msg = Message { text: &amp;code };\n    dbg!(msg);\n}\n&quot;,
}
</code></pre>
    <p>Okay, I did it! What now?</p>
    <p>
      {% sc bearsays %} Now move all the code to construct the
      <code>Message</code> into a separate function! {% endsc %}
    </p>
    <p>Like this?</p>
    <pre><code class="language-rust">#[derive(Debug)]
struct Message&lt;'a&gt; {
    text: &amp;'a str,
}

fn main() {
    let msg = get_msg();
    dbg!(msg);
}

fn get_msg() -&gt; Message {
    let code = std::fs::read_to_string(&quot;src/main.rs&quot;).unwrap();
    Message { text: &amp;code }
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
error[E0106]: missing lifetime specifier
  --&gt; src/main.rs:11:17
   |
11 | fn get_msg() -&gt; Message {
   |                 ^^^^^^^ expected named lifetime parameter
   |
   = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
help: consider using the `'static` lifetime
   |
11 | fn get_msg() -&gt; Message&lt;'static&gt; {
   |                 ~~~~~~~~~~~~~~~~

For more information about this error, try `rustc --explain E0106`.
error: could not compile `grr` due to previous error
</code></pre>
    <p>Erm, not happy.</p>
    <p>
      {% sc bearsays %} Okay, that's lifetime stuff. We're not there yet. What's
      the only thing you use the <code>Message</code> for? {% endsc %}
    </p>
    <p>Passing it to the <code>dbg!</code> macro?</p>
    <p>{% sc bearsays %} And what does that use? {% endsc %}</p>
    <p>Probably the <code>Debug</code> trait?</p>
    <p>
      {% sc bearsays %} So what can we change the return type to? {% endsc %}
    </p>
    <p>Ohhhh <code>impl Debug</code>! To let the compiler figure it out!</p>
    <pre><code class="language-rust">fn get_msg() -&gt; impl std::fmt::Debug {
    let code = std::fs::read_to_string(&quot;src/main.rs&quot;).unwrap();
    Message { text: &amp;code }
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
error[E0597]: `code` does not live long enough
  --&gt; src/main.rs:13:21
   |
11 | fn get_msg() -&gt; impl std::fmt::Debug {
   |                 -------------------- opaque type requires that `code` is borrowed for `'static`
12 |     let code = std::fs::read_to_string(&quot;src/main.rs&quot;).unwrap();
13 |     Message { text: &amp;code }
   |                     ^^^^^ borrowed value does not live long enough
14 | }
   | - `code` dropped here while still borrowed
   |
help: you can add a bound to the opaque type to make it last less than `'static` and match `'static`
   |
11 | fn get_msg() -&gt; impl std::fmt::Debug + 'static {
   |                                      +++++++++

For more information about this error, try `rustc --explain E0597`.
error: could not compile `grr` due to previous error
</code></pre>
    <p>
      Huh. That seems like... a lifetime problem? I thought we weren't at
      lifetimes yet.
    </p>
    <p>{% sc bearsays %} We are now 😎 {% endsc %}</p>
    <h2>Lifetimes and ownership</h2>
    <p>Look this is all moving a little fast for me, I'd just like to-</p>
    <p>
      {% sc bearsays %} You can go back and read the transcript later! For now,
      what's the type returned by <code>std::fs::read_to_string</code>? {% endsc
      %}
    </p>
    <p>Uhhh it's-</p>
    <p>
      {% sc bearsays %} Don't go look at the definition. No time. Just do this:
      {% endsc %}
    </p>
    <pre><code class="language-rust">fn get_msg() -&gt; impl std::fmt::Debug {
    //        👇
    let code: () = std::fs::read_to_string(&quot;src/main.rs&quot;).unwrap();
    Message { text: &amp;code }
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
error[E0308]: mismatched types
  --&gt; src/main.rs:12:20
   |
12 |     let code: () = std::fs::read_to_string(&quot;src/main.rs&quot;).unwrap();
   |               --   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found struct `String`
   |               |
   |               expected due to this
</code></pre>
    <p>
      <a href="https://rust-analyzer.github.io/">rust-analyzer</a> was showing
      me the type as an inlay, you know...
    </p>
    <p>
      {% sc bearsays %} Oh, you installed it! Good. Anyway, it's
      <code>String</code>. Try storing that inside the struct. {% endsc %}
    </p>
    <p>Okay. I guess we won't need that <code>'a</code> anymore...</p>
    <pre><code class="language-rust">#[derive(Debug)]
struct Message {
    //      👇
    text: String,
}

fn main() {
    let msg = get_msg();
    dbg!(msg);
}

fn get_msg() -&gt; impl std::fmt::Debug {
    let code = std::fs::read_to_string(&quot;src/main.rs&quot;).unwrap();
    //               👇 (the `&amp;` is gone)
    Message { text: code }
}
</code></pre>
    <p>
      {% sc bearsays %} Okay, why does this work when the other one didn't? {%
      endsc %}
    </p>
    <p>Because uhhhh, the <code>&amp;str</code> was a... reference?</p>
    <p>{% sc bearsays %} Yes, and? {% endsc %}</p>
    <p>
      And that means it borrowed from something? In this case the result of
      <code>std::fs::read_to_string</code>?
    </p>
    <p>{% sc bearsays %} Yes, and?? {% endsc %}</p>
    <p>
      And that meant we could not return that reference, because
      <code>code</code> dropped (which means it got freed) at the end of the
      function, and so the reference would be dangling?
    </p>
    <p>
      {% sc bearsays %} Veeeery goooood! And it works as a
      <code>String</code> because? {% endsc %}
    </p>
    <p>
      Well, I guess it doesn't borrow? Like, the result of
      <code>read_to_string</code> is <em>moved</em> into <code>Message</code>,
      and so we take ownership of it, and we can move it anywhere we please?
    </p>
    <p>
      {% sc bearsays %} Exactly! Suspiciously exact, even. Are you sure this is
      your first time? {% endsc %}
    </p>
    <p>👼</p>
    <p>
      {% sc bearsays %} Very well, boss baby, do you know of other types that
      let you own a string? {% endsc %}
    </p>
    <p>
      Ah, there's a couple! <code>Box&lt;str&gt;</code> will work, for example:
    </p>
    <pre><code class="language-rust">#[derive(Debug)]
struct Message {
    //     👇
    text: Box&lt;str&gt;,
}

fn main() {
    let msg = get_msg();
    dbg!(msg);
}

fn get_msg() -&gt; impl std::fmt::Debug {
    let code = std::fs::read_to_string(&quot;src/main.rs&quot;).unwrap();
    //               👇
    Message { text: code.into() }
}
</code></pre>
    <p>
      And that one has <em>exclusive</em> ownership. Whereas something like
      <code>Arc&lt;str&gt;</code> will, well, it'll also work:
    </p>
    <pre><code class="language-rust">use std::sync::Arc;

#[derive(Debug)]
struct Message {
    text: Arc&lt;str&gt;,
}
</code></pre>
    <p>
      But that one's <em>shared</em> ownership. You can hand out clones of it
      and so multiple structs can point to the same thing:
    </p>
    <pre><code class="language-rust">use std::sync::Arc;

#[derive(Debug)]
struct Message {
    text: Arc&lt;str&gt;,
}

fn main() {
    let a = get_msg();
    let b = Message {
        text: a.text.clone(),
    };
    let c = Message {
        text: b.text.clone(),
    };
    dbg!(a.text.as_ptr(), b.text.as_ptr(), c.text.as_ptr());
}

fn get_msg() -&gt; Message {
    let code = std::fs::read_to_string(&quot;src/main.rs&quot;).unwrap();
    Message { text: code.into() }
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
[src/main.rs:16] a.text.as_ptr() = 0x0000555f4e9d8d80
[src/main.rs:16] b.text.as_ptr() = 0x0000555f4e9d8d80
[src/main.rs:16] c.text.as_ptr() = 0x0000555f4e9d8d80
</code></pre>
    <p>But you can't modify it.</p>
    <p>
      {% sc bearsays %} Well, it's pretty awkward to mutate a
      <code>&amp;mut str</code> to begin with! {% endsc %}
    </p>
    <p>Yeah. It's easier to show that with a <code>&amp;mut [u8]</code>.</p>
    <p>{% sc bearsays %} Oh you're the professor now huh? {% endsc %}</p>
    <p>Sure! Watch me make a table:</p>
    <p>
      | | Text (UTF-8) | Bytes | | --------------------------- | ------------ |
      ----------- | | Immutable reference / slice | <code>&amp;str</code> |
      <code>&amp;[u8]</code> | | Owned, can grow | <code>String</code> |
      <code>Vec&lt;u8&gt;</code> | | Owned, fixed len |
      <code>Box&lt;str&gt;</code> | <code>Box&lt;[u8]&gt;</code> | | Shared
      ownership (atomic) | <code>Arc&lt;str&gt;</code> |
      <code>Arc&lt;[u8]&gt;</code> |
    </p>
    <p>
      {% sc bearsays %} Now where... where did you find that? You're not even
      telling people about
      <a href="https://doc.rust-lang.org/stable/std/rc/struct.Rc.html">Rc</a>!
      {% endsc %}
    </p>
    <p>
      Eh, by the time they're worried about the cost of atomic reference
      counting, they can do their own research. And then they'll have a nice
      surprise: free performance!
    </p>
    <p>
      There <em>is</em> one thing that's a bit odd, though. In the table above,
      we have an equivalence between <code>str</code> and <code>[u8]</code>.
      What <em>are</em> those types?
    </p>
    <p>{% sc bearsays %} Ah! Those. Well... {% endsc %}</p>
    <h2>Slices and arrays</h2>
    <p>
      {% sc bearsays %} Try printing the size of the <code>str</code> and
      <code>[u8]</code> types! {% endsc %}
    </p>
    <p>Okay sure!</p>
    <pre><code class="language-rust">use std::mem::size_of;

fn main() {
    dbg!(size_of::&lt;str&gt;());
    dbg!(size_of::&lt;[u8]&gt;());
}
</code></pre>
    <p>Wait, no, we can't:</p>
    <pre><code class="language-shell">$ cargo run --quiet
error[E0277]: the size for values of type `str` cannot be known at compilation time
   --&gt; src/main.rs:4:20
    |
4   |     dbg!(size_of::&lt;str&gt;());
    |                    ^^^ doesn't have a size known at compile-time
    |
    = help: the trait `Sized` is not implemented for `str`
note: required by a bound in `std::mem::size_of`
   --&gt; /home/amos/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/mem/mod.rs:304:22
    |
304 | pub const fn size_of&lt;T&gt;() -&gt; usize {
    |                      ^ required by this bound in `std::mem::size_of`

error[E0277]: the size for values of type `[u8]` cannot be known at compilation time
   --&gt; src/main.rs:5:20
    |
5   |     dbg!(size_of::&lt;[u8]&gt;());
    |                    ^^^^ doesn't have a size known at compile-time
    |
    = help: the trait `Sized` is not implemented for `[u8]`
note: required by a bound in `std::mem::size_of`
   --&gt; /home/amos/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/mem/mod.rs:304:22
    |
304 | pub const fn size_of&lt;T&gt;() -&gt; usize {
    |                      ^ required by this bound in `std::mem::size_of`

For more information about this error, try `rustc --explain E0277`.
error: could not compile `grr` due to 2 previous errors
</code></pre>
    <p>
      {% sc bearsays %} Correct! What about the size of
      <code>&amp;str</code> and <code>&amp;[u8]</code>? {% endsc %}
    </p>
    <pre><code class="language-rust">use std::mem::size_of;

fn main() {
    dbg!(size_of::&lt;&amp;str&gt;());
    dbg!(size_of::&lt;&amp;[u8]&gt;());
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
[src/main.rs:4] size_of::&lt;&amp;str&gt;() = 16
[src/main.rs:5] size_of::&lt;&amp;[u8]&gt;() = 16
</code></pre>
    <p>Ah, those we can! 16 bytes, that's... 2x8 bytes... two pointers!</p>
    <p>{% sc bearsays %} Yes! Start and length. {% endsc %}</p>
    <p>
      Okay, so those are always references because... nothing else makes sense?
      Like, we don't know the size of the thing we're borrowing a slice of?
    </p>
    <p>
      {% sc bearsays %} Yes! And the thing we're borrowing from can be... a lot
      of different things. Let's take <code>&amp;[u8]</code> — what types can
      you borrow a <code>&amp;[u8]</code> out of? {% endsc %}
    </p>
    <p>
      Well... the heading says &quot;arrays&quot; so I'm gonna assume it works
      for arrays:
    </p>
    <pre><code class="language-rust">use std::mem::size_of_val;

fn main() {
    let arr = [1, 2, 3, 4, 5];
    let slice = &amp;arr[1..4];
    dbg!(size_of_val(&amp;arr));
    dbg!(size_of_val(&amp;slice));
    print_byte_slice(slice);
}

fn print_byte_slice(slice: &amp;[u8]) {
    println!(&quot;{slice:?}&quot;);
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
[src/main.rs:6] size_of_val(&amp;arr) = 5
[src/main.rs:7] size_of_val(&amp;slice) = 16
[2, 3, 4]
</code></pre>
    <p>Okay, yes.</p>
    <p>{% sc bearsays %} What else? {% endsc %}</p>
    <p>I guess, anything we had in that table under &quot;bytes&quot;?</p>
    <p>It should definitely work for <code>Vec&lt;u8&gt;</code></p>
    <pre><code class="language-rust">use std::mem::size_of_val;

fn main() {
    let vec = vec![1, 2, 3, 4, 5];
    let slice = &amp;vec[1..4];
    dbg!(size_of_val(&amp;vec));
    dbg!(size_of_val(&amp;slice));
    print_byte_slice(slice);
}

fn print_byte_slice(slice: &amp;[u8]) {
    println!(&quot;{slice:?}&quot;);
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
[src/main.rs:6] size_of_val(&amp;vec) = 24
[src/main.rs:7] size_of_val(&amp;slice) = 16
[2, 3, 4]
</code></pre>
    <p>Wait, 24 bytes?</p>
    <p>
      {% sc bearsays %} Yeah! Start, length, capacity. Not necessarily in that
      order. Rust doesn't guarantee a particular type layout anyway, so you
      shouldn't rely on it. {% endsc %}
    </p>
    <p>Next up is Box&lt;[u8]&gt;:</p>
    <pre><code class="language-rust">use std::mem::size_of_val;

fn main() {
    let bbox: Box&lt;[u8]&gt; = Box::new([1, 2, 3, 4, 5]);
    let slice = &amp;bbox[1..4];
    dbg!(size_of_val(&amp;bbox));
    dbg!(size_of_val(&amp;slice));
    print_byte_slice(slice);
}

fn print_byte_slice(slice: &amp;[u8]) {
    println!(&quot;{slice:?}&quot;);
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
[src/main.rs:6] size_of_val(&amp;bbox) = 16
[src/main.rs:7] size_of_val(&amp;slice) = 16
[2, 3, 4]
</code></pre>
    <p>
      Ha, 2x8 bytes each. I suppose... a <code>Box&lt;[u8]&gt;</code> is exactly
      like a <code>&amp;[u8]</code> except... it has ownership of the data it
      points to? So we can move it and stuff? And dropping it frees the data?
    </p>
    <p>
      {% sc bearsays %} Yup! And you forgot one: slices of slices. {% endsc %}
    </p>
    <pre><code class="language-rust">use std::mem::size_of_val;

fn main() {
    let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    let slice = &amp;arr[2..7];
    let slice_of_slice = &amp;slice[2..];
    dbg!(size_of_val(&amp;slice_of_slice));
    print_byte_slice(slice_of_slice);
}

fn print_byte_slice(slice: &amp;[u8]) {
    println!(&quot;{slice:?}&quot;);
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
[src/main.rs:7] size_of_val(&amp;slice_of_slice) = 16
[5, 6, 7]
</code></pre>
    <p>Very cool.</p>
    <p>
      So wait, just to back up — arrays are <code>[T; n]</code>, and slices are
      <code>&amp;[T]</code>. We know the size of arrays because we know how many
      elements they have, and we know the size of <code>&amp;[T]</code> because
      it's just start + length.
    </p>
    <p>But we don't know the size of <code>[T]</code> because...</p>
    <p>
      {% sc bearsays %} Because the slice could borrow from anything! As we've
      seen:
      <code>[u8; n]</code>, <code>Vec&lt;u8&gt;</code>,
      <code>Box&lt;[u8]&gt;</code>, <code>Arc&lt;[u8]&gt;</code>, another
      slice... {% endsc %}
    </p>
    <p>Ah. So we don't know its size.</p>
    <p>Wait wait wait.</p>
    <p>
      That makes <code>[T]</code> a dynamically-sized type? Just like trait
      objects?
    </p>
    <p>{% sc bearsays %} Yes, it is a DST. {% endsc %}</p>
    <p>And we can just do <code>Box&lt;[T]&gt;</code>?</p>
    <p>{% sc bearsays %} Sure! That's just an owning pointer. {% endsc %}</p>
    <p>Ooooh that gives me an idea.</p>
    <h2>Boxed trait objects</h2>
    <p>
      So! Deep breaths. If I followed correctly, that means that, although we
      don't know the size of <code>dyn Display</code>, we know the size of
      <code>Box&lt;dyn Display&gt;</code> — it should be the same size as
      <code>&amp;dyn Display</code>, it just has ownership of its... of the
      thing it points to.
    </p>
    <p>
      {% sc bearsays %} Its pointee, yeah. Also, same with
      <code>Arc&lt;dyn Display&gt;</code>, or any other smart pointer. {% endsc
      %}
    </p>
    <p>Okay let me check it real quick:</p>
    <pre><code class="language-rust">use std::{fmt::Display, mem::size_of, rc::Rc, sync::Arc};

fn main() {
    dbg!(size_of::&lt;&amp;dyn Display&gt;());
    dbg!(size_of::&lt;Box&lt;dyn Display&gt;&gt;());
    dbg!(size_of::&lt;Arc&lt;dyn Display&gt;&gt;());
    dbg!(size_of::&lt;Rc&lt;dyn Display&gt;&gt;());
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
[src/main.rs:4] size_of::&lt;&amp;dyn Display&gt;() = 16
[src/main.rs:5] size_of::&lt;Box&lt;dyn Display&gt;&gt;() = 16
[src/main.rs:6] size_of::&lt;Arc&lt;dyn Display&gt;&gt;() = 16
[src/main.rs:7] size_of::&lt;Rc&lt;dyn Display&gt;&gt;() = 16
</code></pre>
    <p>
      Okay, okay! They're all the same size, the size of a p-.. of two pointers?
      What?
    </p>
    <p>
      {% sc bearsays %} Yeah! Data and vtable. You remember how you couldn't do
      anything with the values in your first generic function? {% endsc %}
    </p>
    <p>That one?</p>
    <pre><code class="language-rust">fn show&lt;T&gt;(a: T) {
    todo!()
}
</code></pre>
    <p>
      {% sc bearsays %} The very same. Well there's two ways to solve this.
      Either you add a trait bound, like so: {% endsc %}
    </p>
    <pre><code class="language-rust">fn show&lt;T: std::fmt::Display&gt;(a: T) {
    // blah
}
</code></pre>
    <p>
      {% sc bearsays %} And then a different version of <code>show</code> gets
      generated for every type you call it with. {% endsc %}
    </p>
    <p>Oooh, right! That's uhh... it's called... discombobulation?</p>
    <p>
      {% sc bearsays %}
      <a href="https://en.wikipedia.org/wiki/Monomorphization"
        >Monomorphization</a
      >. <code>show</code> is &quot;polymorphic&quot; because it can take
      multiple forms, and it gets replaced with many &quot;monomorphic&quot;
      versions of itself, that each handle a certain combination of types. {%
      endsc %}
    </p>
    <p>Okay, so that's one way. And the other way?</p>
    <p>
      {% sc bearsays %} You take a reference to a trait object:
      <code>&amp;dyn Trait</code>. {% endsc %}
    </p>
    <p>And that helps how?</p>
    <p>
      {% sc bearsays %} Well, it points to the value itself, <em>and</em> a list
      of all functions required by the trait. And only those. {% endsc %}
    </p>
    <p>
      Oh. Oh! And that's the vtable? It's just &quot;the concrete type's
      implementation of every function listed in the trait definition&quot;?
    </p>
    <p>
      {% sc bearsays %} Yes. But can you define &quot;concrete type&quot; for
      me? {% endsc %}
    </p>
    <p>Well... let's take this:</p>
    <pre><code class="language-rust">use std::fmt::Display;

fn main() {
    let x: u64 = 42;
    show(x);
}

fn show&lt;D: Display&gt;(d: D) {
    println!(&quot;{}&quot;, d);
}
</code></pre>
    <p>
      In that case, I'd call <code>D</code> the type parameter (or generic
      type?), and <code>u64</code> the concrete type.
    </p>
    <p>
      {% sc bearsays %} Okay, I was just making sure. You were about to have an
      epiphany? {% endsc %}
    </p>
    <p>I was? Oh, right!</p>
    <pre><code class="language-shell">$ cargo run --quiet
[src/main.rs:4] size_of::&lt;&amp;dyn Display&gt;() = 16
[src/main.rs:5] size_of::&lt;Box&lt;dyn Display&gt;&gt;() = 16
[src/main.rs:6] size_of::&lt;Arc&lt;dyn Display&gt;&gt;() = 16
[src/main.rs:7] size_of::&lt;Rc&lt;dyn Display&gt;&gt;() = 16
</code></pre>
    <p>So these all have the same size.</p>
    <p>
      And the last time we tried returning a <code>dyn Display</code> we ran
      into trouble because, well, it's dynamically-sized:
    </p>
    <pre><code class="language-rust">use std::fmt::Display;

fn main() {
    let x = get_display();
    show(x);
}

fn get_display() -&gt; dyn Display {
    let x: u64 = 42;
    x
}

fn show&lt;D: Display&gt;(d: D) {
    println!(&quot;{}&quot;, d);
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
error[E0746]: return type cannot have an unboxed trait object
 --&gt; src/main.rs:3:21
  |
3 | fn get_display() -&gt; dyn Display {
  |                     ^^^^^^^^^^^ doesn't have a size known at compile-time
  |
  = note: for information on `impl Trait`, see &lt;https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits&gt;
help: use `impl Display` as the return type, as all return paths are of type `u64`, which implements `Display`
  |
3 | fn get_display() -&gt; impl Display {
  |                     ~~~~~~~~~~~~

(other errors omitted)
</code></pre>
    <p>But <code>-&gt; impl Display</code> worked, as the compiler suggests:</p>
    <pre><code class="language-rust">fn get_display() -&gt; impl Display {
    let x: u64 = 42;
    x
}
</code></pre>
    <p>Because it's sorta like this:</p>
    <pre><code class="language-rust">fn get_display&lt;D: Display&gt;() -&gt; D {
    let x: u64 = 42;
    x
}
</code></pre>
    <p>
      {% sc bearsays %} Nooooooo no no no. Verboten. Can't do that! {% endsc %}
    </p>
    <p>Yeah, you told me! You didn't explain why, though.</p>
    <p>{% sc bearsays %} Because, and read this very carefully:</p>
    <p>
      When a generic function is called, it must be possible to infer all its
      type parameters from its inputs alone. {% endsc %}
    </p>
    <p>
      Ah, erm. Wait so it would work if <code>D</code> was also somewhere in the
      type of a parameter?
    </p>
    <p>{% sc bearsays %} Yeah! Consider this: {% endsc %}</p>
    <pre><code class="language-rust">fn main() {
    dbg!(add_10(5));
}

fn add_10&lt;N&gt;(n: N) -&gt; N {
    n + 10
}
</code></pre>
    <p>Wait, that doesn't compile!</p>
    <pre><code class="language-shell">$ cargo run --quiet
error[E0369]: cannot add `{integer}` to `N`
 --&gt; src/main.rs:6:7
  |
6 |     n + 10
  |     - ^ -- {integer}
  |     |
  |     N
</code></pre>
    <p>{% sc bearsays %} No. But you also truncated the compiler's output.</p>
    <p>Here's the rest of it. {% endsc %}</p>
    <pre><code class="language-rust">help: consider restricting type parameter `N`
  |
5 | fn add_10&lt;N: std::ops::Add&lt;Output = {integer}&gt;&gt;(n: N) -&gt; N {
  |            +++++++++++++++++++++++++++++++++++
</code></pre>
    <p>
      {% sc bearsays %} It's not the same issue. The problem here is that
      <code>N</code> could be <em>anything</em>. Including types that we cannot
      add 10 to.
    </p>
    <p>Here's a working version: {% endsc %}</p>
    <pre><code class="language-rust">fn main() {
    dbg!(add_10(1_u8));
    dbg!(add_10(2_u16));
    dbg!(add_10(3_u32));
    dbg!(add_10(4_u64));
}

fn add_10&lt;N&gt;(n: N) -&gt; N
where
    N: From&lt;u8&gt; + std::ops::Add&lt;Output = N&gt;,
{
    n + 10.into()
}
</code></pre>
    <p>Yeesh that's... gnarly.</p>
    <p>
      {% sc bearsays %} Yeah. It's also a super contrived example. {% endsc %}
    </p>
    <p>
      But okay, I get it: <code>impl Trait</code> in return position is the only
      way to have something about the function signature that's inferred from...
      its body.
    </p>
    <p>
      {% sc bearsays %} Yes! Which is why both these <code>get_</code> functions
      work: {% endsc %}
    </p>
    <pre><code class="language-rust">use std::fmt::Display;

fn main() {
    show(get_char());
    show(get_int());
}

fn get_char() -&gt; impl Display {
    'C'
}

fn get_int() -&gt; impl Display {
    64
}

fn show(v: impl Display) {
    println!(&quot;{v}&quot;);
}
</code></pre>
    <p>
      Right, it infers the return type of <code>get_char</code> to be
      <code>char</code>, and the ret-
    </p>
    <p>
      {% sc bearsays %} Not quite. Well, yes. But it returns an
      <em>opaque</em> type. The caller doesn't know it's actually a
      <code>char</code>. All it knows is that it implements
      <code>Display</code>. {% endsc %}
    </p>
    <p>I see.</p>
    <p>
      {% sc bearsays %} Still, by itself, it can't <em>unify</em>
      <code>char</code> and <code>i32</code>, for example. Those are two
      distinct types. {% endsc %}
    </p>
    <p>I wonder what <code>type_name</code> thinks of these...</p>
    <pre><code class="language-rust">use std::fmt::Display;

fn main() {
    let c = get_char();
    dbg!(type_name_of(&amp;c));
    let i = get_int();
    dbg!(type_name_of(&amp;i));
}

fn get_char() -&gt; impl Display {
    'C'
}

fn get_int() -&gt; impl Display {
    64
}

fn type_name_of&lt;T&gt;(_: T) -&gt; &amp;'static str {
    std::any::type_name::&lt;T&gt;()
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
[src/main.rs:5] type_name_of(&amp;c) = &quot;&amp;char&quot;
[src/main.rs:7] type_name_of(&amp;i) = &quot;&amp;i32&quot;
</code></pre>
    <p>Hahahaha. Not so opaque after all.</p>
    <p>
      {% sc bearsays %} That's uhh.. didn't expect <code>type_name</code> to do
      that, to be honest.
    </p>
    <p>
      But they <em>are</em> opaque, I promise. You can call
      <code>char</code> methods on a real <code>char</code>, but not on the
      return type of <code>get_char</code>: {% endsc %}
    </p>
    <pre><code class="language-rust">use std::fmt::Display;

fn main() {
    let real_c = 'a';
    dbg!(real_c.to_ascii_uppercase());

    let opaque_c = get_char();
    dbg!(opaque_c.to_ascii_uppercase());
}

fn get_char() -&gt; impl Display {
    'C'
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
error[E0599]: no method named `to_ascii_uppercase` found for opaque type `impl std::fmt::Display` in the current scope
 --&gt; src/main.rs:8:19
  |
8 |     dbg!(opaque_c.to_ascii_uppercase());
  |                   ^^^^^^^^^^^^^^^^^^ method not found in `impl std::fmt::Display`

For more information about this error, try `rustc --explain E0599`.
error: could not compile `grr` due to previous error
</code></pre>
    <p>
      {% sc bearsays %} Also, I'm fairly sure <code>type_id</code> will give us
      different values... {% endsc %}
    </p>
    <pre><code class="language-rust">use std::{any::TypeId, fmt::Display};

fn main() {
    let opaque_c = get_char();
    dbg!(type_id_of(opaque_c));

    let real_c = 'a';
    dbg!(type_id_of(real_c));
}

fn get_char() -&gt; impl Display {
    'C'
}

fn type_id_of&lt;T: 'static&gt;(_: T) -&gt; TypeId {
    TypeId::of::&lt;T&gt;()
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
[src/main.rs:5] type_id_of(opaque_c) = TypeId {
    t: 15782864888164328018,
}
[src/main.rs:8] type_id_of(real_c) = TypeId {
    t: 15782864888164328018,
}
</code></pre>
    <p>{% sc bearsays %} Ah, huh. I guess not. {% endsc %}</p>
    <p>
      Yeah it seems like opaque types are a type-checker trick and it
      <em>is</em> the concrete type at runtime. The checker will just have
      prevented us from calling anything that wasn't in the trait.
    </p>
    <p>Actually, now I understand better why this cannot work:</p>
    <pre><code class="language-rust">use std::fmt::Display;

fn main() {
    show(get_char_or_int(true));
    show(get_char_or_int(false));
}

fn get_char_or_int(give_char: bool) -&gt; impl Display {
    if give_char {
        'C'
    } else {
        64
    }
}

fn show(v: impl Display) {
    println!(&quot;{v}&quot;);
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
error[E0308]: `if` and `else` have incompatible types
  --&gt; src/main.rs:12:9
   |
9  | /     if give_char {
10 | |         'C'
   | |         --- expected because of this
11 | |     } else {
12 | |         64
   | |         ^^ expected `char`, found integer
13 | |     }
   | |_____- `if` and `else` have incompatible types

For more information about this error, try `rustc --explain E0308`.
error: could not compile `grr` due to previous error
</code></pre>
    <p>
      It's because the return type cannot be simultaneously
      <code>char</code> and, say, <code>i32</code>.
    </p>
    <p>
      {% sc bearsays %} Yes, and also: it's because there's no vtable involved.
      Remember the <code>enum</code> version you did? {% endsc %}
    </p>
    <p>Yeah! That one:</p>
    <pre><code class="language-rust">use delegate::delegate;
use std::fmt::Display;

fn main() {
    show(get_char_or_int(true));
    show(get_char_or_int(false));
}

impl Either {
    fn display(&amp;self) -&gt; &amp;dyn Display {
        match self {
            Either::Char(c) =&gt; c,
            Either::Int(i) =&gt; i,
        }
    }
}

impl Display for Either {
    delegate! {
        to self.display() {
            fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result;
        }
    }
}

enum Either {
    Char(char),
    Int(i64),
}

fn get_char_or_int(give_char: bool) -&gt; Either {
    if give_char {
        Either::Char('C')
    } else {
        Either::Int(64)
    }
}

fn show(v: impl Display) {
    println!(&quot;{v}&quot;);
}
</code></pre>
    <p>
      {% sc bearsays %} Right! In that one, you're manually dispatching
      <code>Display::fmt</code> to either the implementation for
      <code>char</code> or the one for <code>i64</code>. {% endsc %}
    </p>
    <p>Well no, <code>delegate</code> is doing it for me.</p>
    <p>{% sc bearsays %} Well, you did it here: {% endsc %}</p>
    <pre><code class="language-rust">impl Display for Either {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        match self {
            Either::Char(c) =&gt; c.fmt(f),
            Either::Int(i) =&gt; i.fmt(f),
        }
    }
}
</code></pre>
    <p>Right, yes, I see the idea. So a vtable does the same thing?</p>
    <p>
      {% sc bearsays %} Eh, not quite. It's more like function pointers. {%
      endsc %}
    </p>
    <p>Can you show me?</p>
    <p>{% sc bearsays %} Okay, but real quick then. {% endsc %}</p>
    <pre><code class="language-rust">use std::{
    fmt::{self, Display},
    mem::transmute,
};

// This is our type that can contain any value that implements `Display`
struct BoxedDisplay {
    // This is a pointer to the actual value, which is on the heap.
    data: *mut (),
    // And this is a reference to the vtable for Display's implementation of the
    // type of our value.
    vtable: &amp;'static DisplayVtable&lt;()&gt;,
}

// 👆 Note that there are no type parameters at all in the above type. The
// type is _erased_.

// Then we need to declare our vtable type.
// This is a type-safe take on it (thanks @eddyb for the idea), but you may
// have noticed `BoxedDisplay` pretends they're all `DisplayVtable&lt;()&gt;`, which
// is fine because we're only dealing with pointers to `T` / `()`, which all
// have the same size.
#[repr(C)]
struct DisplayVtable&lt;T&gt; {
    // This is the implementation of `Display::fmt` for `T`
    fmt: unsafe fn(*mut T, &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result,

    // We also need to be able to drop a `T`. For that we need to know how large
    // `T` is, and there may be side effects (freeing OS resources, flushing a
    // buffer, etc.) so it needs to go into the vtable too.
    drop: unsafe fn(*mut T),
}

impl&lt;T: Display&gt; DisplayVtable&lt;T&gt; {
    // This lets us build a `DisplayVtable` any `T` that implements `Display`
    fn new() -&gt; &amp;'static Self {
        // Why yes you can declare functions in that scope. This one just
        // forwards to `T`'s `Display` implementation.
        unsafe fn fmt&lt;T: Display&gt;(this: *mut T, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
            (*this).fmt(f)
        }

        // Here we turn a raw pointer (`*mut T`) back into a `Box&lt;T&gt;`, which
        // has ownership of it and thus, knows how to drop (free) it.
        unsafe fn drop&lt;T&gt;(this: *mut T) {
            Box::from_raw(this);
        }

        // 👆 These are both regular functions, not, closures. They end up in
        // the executable, thus they live for 'static, thus we can return a
        // `&amp;'static Self` as requested.

        &amp;Self { fmt, drop }
    }
}

// Okay, now we can make a constructor for `BoxedDisplay` itself!
impl BoxedDisplay {
    // The `'static` bound makes sure `T` is _owned_ (it can't be a reference
    // shorter than 'static).
    fn new&lt;T: Display + 'static&gt;(t: T) -&gt; Self {
        // Let's do some type erasure!
        Self {
            // Box&lt;T&gt; =&gt; *mut T =&gt; *mut ()
            data: Box::into_raw(Box::new(t)) as _,

            // &amp;'static DisplayVtable&lt;T&gt; =&gt; &amp;'static DisplayVtable&lt;()&gt;
            vtable: unsafe { transmute(DisplayVtable::&lt;T&gt;::new()) },
        }
    }
}

// That one's easy — we dispatch to the right `fmt` function using the vtable.
impl Display for BoxedDisplay {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        unsafe { (self.vtable.fmt)(self.data, f) }
    }
}

// Same here.
impl Drop for BoxedDisplay {
    fn drop(&amp;mut self) {
        unsafe {
            (self.vtable.drop)(self.data);
        }
    }
}

// And finally, we can use it!
fn get_char_or_int(give_char: bool) -&gt; BoxedDisplay {
    if give_char {
        BoxedDisplay::new('C')
    } else {
        BoxedDisplay::new(64)
    }
}

fn show(v: impl Display) {
    println!(&quot;{v}&quot;);
}

fn main() {
    show(get_char_or_int(true));
    show(get_char_or_int(false));
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
C
64
</code></pre>
    <p>Whoa. Whoa whoa whoa, that could be its own article!</p>
    <p>{% sc bearsays %} Yes. And yet here we are. {% endsc %}</p>
    <p>
      And there's <code>unsafe</code> code in there, how do you know it's okay?
    </p>
    <p>
      {% sc bearsays %} Well,
      <a href="https://github.com/rust-lang/miri#readme">miri</a> is happy about
      it, so that's a good start: {% endsc %}
    </p>
    <pre><code class="language-shell">$ cargo +nightly miri run --quiet
C
64
</code></pre>
    <p>And do I really need to write code like that?</p>
    <p>
      {% sc bearsays %} No you don't! But you can, and the standard library does
      have code <em>like that</em>, which is awesome, because you don't need to
      learn a whole other language to drop down and work on it. {% endsc %}
    </p>
    <p>Wait, unsafe Rust is not a whole other language?</p>
    <p>{% sc bearsays %} Touché, smartass. {% endsc %}</p>
    <p>
      {% sc bearsays %} Anyway you don't need to write all of that yourself
      because that's <em>exactly</em> what
      <code>Box&lt;dyn Display&gt;</code> already is. {% endsc %}
    </p>
    <p>Oh, word?</p>
    <pre><code class="language-rust">use std::fmt::Display;

fn get_char_or_int(give_char: bool) -&gt; Box&lt;dyn Display&gt; {
    if give_char {
        Box::new('C')
    } else {
        Box::new(64)
    }
}

fn show(v: impl Display) {
    println!(&quot;{v}&quot;);
}

fn main() {
    show(get_char_or_int(true));
    show(get_char_or_int(false));
}
</code></pre>
    <pre><code class="language-shell">$ cargo run --quiet
C
64
</code></pre>
    <p>Neat! Super neat.</p>
    <p>
      {% sc bearsays %} Really the &quot;magic&quot; happens in the trait object
      itself. Here it's boxed, but it may as well be arc'd: {% endsc %}
    </p>
    <pre><code class="language-rust">fn get_char_or_int(give_char: bool) -&gt; Arc&lt;dyn Display&gt; {
    if give_char {
        Arc::new('C')
    } else {
        Arc::new(64)
    }
}
</code></pre>
    <p>
      {% sc bearsays %} And that would work just as well. Or, again, just a
      reference: {% endsc %}
    </p>
    <pre><code class="language-rust">fn get_char_or_int(give_char: bool) -&gt; &amp;'static dyn Display {
    if give_char {
        &amp;'C'
    } else {
        &amp;64
    }
}
</code></pre>
    <p>
      Well, that's a comfort. For a second there I really thought I would have
      to write my own custom vtable implementation every time I want to do
      something useful.
    </p>
    <p>
      {% sc bearsays %} No, this isn't the 1970s. We have re-usable code now. {%
      endsc %}
    </p>
    <h2>Reading type signatures</h2>
    <p>
      Ok so... there's a lot of different names for essentially the same thing,
      like
      <code>&amp;str</code> and <code>String</code>, and
      <code>&amp;[u8]</code> and <code>Vec&lt;u8&gt;</code>, etc.
    </p>
    <p>Seems like a bunch of extra work. What's the upside?</p>
    <p>{% sc bearsays %} Well, sometimes it catches bugs. {% endsc %}</p>
    <p>Ah!</p>
    <p>
      {% sc bearsays %} The big thing there is lifetimes, in the context of
      concurrent code, but... {% endsc %}
    </p>
    <p>Whoa there, I don't think we've-</p>
    <p>{% sc bearsays %} BUT, immutability is another big one.</p>
    <p>Consider this: {% endsc %}</p>
    <pre><code class="language-js">function double(arr) {
  for (var i = 0; i &lt; arr.length; i++) {
    arr[i] *= 2;
  }
  return arr;
}

let a = [1, 2, 3];
console.log({ a });
let b = double(a);
console.log({ b });
</code></pre>
    <p>
      Ah, easy! This'll print <code>1, 2, 3</code> and then
      <code>2, 4, 6</code>.
    </p>
    <pre><code class="language-shell">$ node main.js
{ a: [ 1, 2, 3 ] }
{ b: [ 2, 4, 6 ] }
</code></pre>
    <p>Called it!</p>
    <p>{% sc bearsays %} Now what if we call it like this? {% endsc %}</p>
    <pre><code class="language-javascript">let a = [1, 2, 3];
console.log({ a });
let b = double(a);
console.log({ a, b });
</code></pre>
    <p>
      Ah, then, mh... <code>1, 2, 3</code> and then... <code>1, 2, 3</code> and
      <code>2, 4, 6</code>?
    </p>
    <p>{% sc bearsays %} Wrong! {% endsc %}</p>
    <pre><code class="language-shell">$ node main.js
{ a: [ 1, 2, 3 ] }
{ a: [ 2, 4, 6 ], b: [ 2, 4, 6 ] }
</code></pre>
    <p>
      Ohhh! Right I suppose <code>double</code> took the array by reference, and
      so it mutated it in-place.
    </p>
    <p>
      Mhhh. I guess we have to think about these things in ECMAScript-land, too.
    </p>
    <p>
      {% sc bearsays %} We very much do! We can &quot;fix&quot; it like this for
      example: {% endsc %}
    </p>
    <pre><code class="language-javascript">function double(arr) {
  let result = new Array(arr.length);
  for (var i = 0; i &lt; arr.length; i++) {
    result[i] = arr[i] * 2;
  }
  return result;
}
</code></pre>
    <pre><code class="language-shell">$ node main.js
{ a: [ 1, 2, 3 ] }
{ a: [ 1, 2, 3 ], b: [ 2, 4, 6 ] }
</code></pre>
    <p>Wait, wouldn't we rather use a functional style, like so?</p>
    <pre><code class="language-javascript">function double(arr) {
  return arr.map((x) =&gt; x * 2);
}
</code></pre>
    <p>
      {% sc bearsays %} That works too! It's just 86% slower according to this
      <a href="https://jsbench.me/sbl3viasq8/1">awful microbenchmark</a> I just
      made. {% endsc %}
    </p>
    <p>Aw, nuts. We have to worry about performance too in ECMAScript-land?</p>
    <p>
      {% sc bearsays %} You can if you want to! But let's stay on
      &quot;correctness&quot;.
    </p>
    <p>Let's try porting those functions to Rust. {% endsc %}</p>
    <pre><code class="language-rust">fn main() {
    let a = vec![1, 2, 3];
    println!(&quot;a = {a:?}&quot;);
    let b = double(a);
    println!(&quot;b = {b:?}&quot;);
}

fn double(a: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    a.into_iter().map(|x| x * 2).collect()
}
</code></pre>
    <p>Let's give it a run...</p>
    <pre><code class="language-shell">$ cargo run -q
a = [1, 2, 3]
b = [2, 4, 6]
</code></pre>
    <p>Yeah that checks out.</p>
    <p>
      {% sc bearsays %} So, same question as before: do you think
      <code>double</code> is messing with <code>a</code>? {% endsc %}
    </p>
    <p>I don't think so?</p>
    <p>{% sc bearsays %} Try printing it! {% endsc %}</p>
    <pre><code class="language-rust">fn main() {
    let a = vec![1, 2, 3];
    println!(&quot;a = {a:?}&quot;);
    let b = double(a);
    println!(&quot;a = {a:?}&quot;);
    println!(&quot;b = {b:?}&quot;);
}
</code></pre>
    <pre><code class="language-shell">$ cargo run -q
error[E0382]: borrow of moved value: `a`
 --&gt; src/main.rs:5:20
  |
2 |     let a = vec![1, 2, 3];
  |         - move occurs because `a` has type `Vec&lt;i32&gt;`, which does not implement the `Copy` trait
3 |     println!(&quot;a = {a:?}&quot;);
4 |     let b = double(a);
  |                    - value moved here
5 |     println!(&quot;a = {a:?}&quot;);
  |                    ^ value borrowed here after move
  |
  = note: this error originates in the macro `$crate::format_args_nl` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0382`.
error: could not compile `grr` due to previous error
</code></pre>
    <p>
      Wait, we can't. <code>double</code> takes ownership of <code>a</code>, so
      there's no <code>a</code> left for us to print.
    </p>
    <p>{% sc bearsays %} Correct! What about this version? {% endsc %}</p>
    <pre><code class="language-rust">fn main() {
    let a = vec![1, 2, 3];
    println!(&quot;a = {a:?}&quot;);
    let b = double(&amp;a);
    println!(&quot;a = {a:?}&quot;);
    println!(&quot;b = {b:?}&quot;);
}

fn double(a: &amp;Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    a.iter().map(|x| x * 2).collect()
}
</code></pre>
    <p>That one... mhh that one should work?</p>
    <p>{% sc bearsays %} It does! {% endsc %}</p>
    <pre><code class="language-shell">$ cargo run -q
a = [1, 2, 3]
a = [1, 2, 3]
b = [2, 4, 6]
</code></pre>
    <p>
      {% sc bearsays %} But tell me, do we <em>really</em> need to take a
      <code>&amp;Vec</code>? {% endsc %}
    </p>
    <p>What do you mean?</p>
    <p>
      {% sc bearsays %} Well, a <code>Vec&lt;T&gt;</code> is neat because it can
      grow, and shrink. This is useful when collecting results, for example, and
      we don't know how many results we'll end up having. We need to be able to
      push elements onto it, without worrying about running out of space. {%
      endsc %}
    </p>
    <p>
      I suppose so yeah? Well in our case... I suppose all we do is read from
      <code>a</code>, so no, we don't really need a <code>&amp;Vec</code>. But
      what else would we take?
    </p>
    <p>{% sc bearsays %} Let's ask clippy! {% endsc %}</p>
    <pre><code class="language-shell">$ cargo clippy -q
warning: writing `&amp;Vec` instead of `&amp;[_]` involves a new object where a slice will do
 --&gt; src/main.rs:9:14
  |
9 | fn double(a: &amp;Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
  |              ^^^^^^^^^ help: change this to: `&amp;[i32]`
  |
  = note: `#[warn(clippy::ptr_arg)]` on by default
  = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#ptr_arg
</code></pre>
    <p>Ohhhh a slice, of course!</p>
    <pre><code class="language-rust">fn double(a: &amp;[i32]) -&gt; Vec&lt;i32&gt; {
    a.iter().map(|x| x * 2).collect()
}
</code></pre>
    <p>
      {% sc bearsays %} And now does <em>this</em> version mess with
      <code>a</code>? {% endsc %}
    </p>
    <p>
      Oh definitely not. Our <code>a</code> in the <code>main</code> function is
      a growable <code>Vec</code>, and we pass a read-only slice of it to the
      function, so all it can do is read.
    </p>
    <p>{% sc bearsays %} Correct! {% endsc %}</p>
    <pre><code class="language-shell">$ cargo run -q
a = [1, 2, 3]
a = [1, 2, 3]
b = [2, 4, 6]
</code></pre>
    <p>{% sc bearsays %} How about this one: {% endsc %}</p>
    <pre><code class="language-rust">fn double(a: &amp;mut [i32]) -&gt; Vec&lt;i32&gt; {
    a.iter().map(|x| x * 2).collect()
}
</code></pre>
    <p>Well, seems unnecessary? And.. it doesn't compile:</p>
    <pre><code class="language-shell">$ cargo run -q
error[E0308]: mismatched types
 --&gt; src/main.rs:4:20
  |
4 |     let b = double(&amp;a);
  |                    ^^ types differ in mutability
  |
  = note: expected mutable reference `&amp;mut [i32]`
                     found reference `&amp;Vec&lt;{integer}&gt;`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `grr` due to previous error
</code></pre>
    <p>{% sc bearsays %} So? Make it compile! {% endsc %}</p>
    <p>Alright then:</p>
    <pre><code class="language-rust">fn main() {
    //   👇
    let mut a = vec![1, 2, 3];
    println!(&quot;a = {a:?}&quot;);
    //                         👇
    let b = double(&amp;mut a);
    println!(&quot;a = {a:?}&quot;);
    println!(&quot;b = {b:?}&quot;);
}

fn double(a: &amp;mut [i32]) -&gt; Vec&lt;i32&gt; {
    a.iter().map(|x| x * 2).collect()
}
</code></pre>
    <p>There. It prints exactly the same thing.</p>
    <p>{% sc bearsays %} So this works. But is it good? {% endsc %}</p>
    <p>Not really no. We're asking for more than what we need.</p>
    <p>
      {% sc bearsays %} Indeed! We never mutate the input, so we don't need a
      mutable slice of it.
    </p>
    <p>But can you show a case where it would get in the way? {% endsc %}</p>
    <p>
      Yes I suppose... I suppose if we wanted to double the input in parallel a
      bunch of times? I mean it's pretty contrived, but.. gimme a second.
    </p>
    <pre><code class="language-shell">$ cargo add crossbeam
(cut)
</code></pre>
    <pre><code class="language-rust">fn main() {
    let mut a = vec![1, 2, 3];
    println!(&quot;a = {a:?}&quot;);

    crossbeam::scope(|s| {
        for _ in 0..5 {
            s.spawn(|_| {
                let b = double(&amp;mut a);
                println!(&quot;b = {b:?}&quot;);
            });
        }
    })
    .unwrap();
}

fn double(a: &amp;mut [i32]) -&gt; Vec&lt;i32&gt; {
    a.iter().map(|x| x * 2).collect()
}
</code></pre>
    <p>
      There. That fails because we can't borrow <code>a</code> mutably more than
      once at a time:
    </p>
    <pre><code class="language-shell">$ cargo run -q
error[E0499]: cannot borrow `a` as mutable more than once at a time
  --&gt; src/main.rs:7:21
   |
5  |       crossbeam::scope(|s| {
   |                         - has type `&amp;crossbeam::thread::Scope&lt;'1&gt;`
6  |           for _ in 0..5 {
7  |               s.spawn(|_| {
   |               -       ^^^ `a` was mutably borrowed here in the previous iteration of the loop
   |  _____________|
   | |
8  | |                 let b = double(&amp;mut a);
   | |                                     - borrows occur due to use of `a` in closure
9  | |                 println!(&quot;b = {b:?}&quot;);
10 | |             });
   | |______________- argument requires that `a` is borrowed for `'1`

For more information about this error, try `rustc --explain E0499`.
error: could not compile `grr` due to previous error
</code></pre>
    <p>But it works if we just take an immutable reference:</p>
    <pre><code class="language-rust">fn main() {
    let a = vec![1, 2, 3];
    println!(&quot;a = {a:?}&quot;);

    crossbeam::scope(|s| {
        for _ in 0..5 {
            s.spawn(|_| {
                let b = double(&amp;a);
                println!(&quot;b = {b:?}&quot;);
            });
        }
    })
    .unwrap();
}

fn double(a: &amp;[i32]) -&gt; Vec&lt;i32&gt; {
    a.iter().map(|x| x * 2).collect()
}
</code></pre>
    <pre><code class="language-shell">$ cargo run -q
a = [1, 2, 3]
b = [2, 4, 6]
b = [2, 4, 6]
b = [2, 4, 6]
b = [2, 4, 6]
b = [2, 4, 6]
</code></pre>
    <p>
      {% sc bearsays %} Very good! Look at you! And you used
      <a href="https://lib.rs/crates/crossbeam">crossbeam</a> because? {% endsc
      %}
    </p>
    <p>
      Because... something something scoped threads. Forget about that part. You
      got what you wanted, right?
    </p>
    <p>
      {% sc bearsays %} I did! Next question: doesn't this code have the exact
      same performance issues as our ECMAScript <code>.map()</code>-based
      function? {% endsc %}
    </p>
    <p>
      Yes and no — we <em>are</em> allocating a new <code>Vec</code>, but it
      probably has the exact right size to begin with, because Rust iterators
      have
      <a
        href="https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.size_hint"
        >size hints</a
      >.
    </p>
    <p>
      {% sc bearsays %} Ah, mh, okay, but what if we <em>did</em> want to mutate
      the vec in-place? {% endsc %}
    </p>
    <p>Ah, then I suppose we could do this:</p>
    <pre><code class="language-rust">fn main() {
    let a = vec![1, 2, 3];
    println!(&quot;a = {a:?}&quot;);

    let b = double(a);
    println!(&quot;b = {b:?}&quot;);
}

fn double(a: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    for i in 0..a.len() {
        a[i] *= 2;
    }
    a
}
</code></pre>
    <p>Wait, no:</p>
    <pre><code class="language-shell">$ cargo run -q
error[E0596]: cannot borrow `a` as mutable, as it is not declared as mutable
  --&gt; src/main.rs:11:9
   |
9  | fn double(a: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
   |           - help: consider changing this to be mutable: `mut a`
10 |     for i in 0..a.len() {
11 |         a[i] *= 2;
   |         ^ cannot borrow as mutable

For more information about this error, try `rustc --explain E0596`.
error: could not compile `grr` due to previous error
</code></pre>
    <p>I mean this:</p>
    <pre><code class="language-rust">fn double(mut a: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    for i in 0..a.len() {
        a[i] *= 2;
    }
    a
}
</code></pre>
    <p>Wait, no:</p>
    <pre><code class="language-shell">$ cargo clippy -q
warning: the loop variable `i` is only used to index `a`
  --&gt; src/main.rs:10:14
   |
10 |     for i in 0..a.len() {
   |              ^^^^^^^^^^
   |
   = note: `#[warn(clippy::needless_range_loop)]` on by default
   = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#needless_range_loop
help: consider using an iterator
   |
10 |     for &lt;item&gt; in &amp;mut a {
   |         ~~~~~~    ~~~~~~

</code></pre>
    <p>I mean this:</p>
    <pre><code class="language-rust">fn double(mut a: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    for x in a.iter_mut() {
        *x *= 2;
    }
    a
}
</code></pre>
    <p>
      {% sc bearsays %} Okay, no need to run it, I know what it does. But is it
      <em>good</em>? {% endsc %}
    </p>
    <p>Idk. Seems okay? What's wrong with it?</p>
    <p>
      {% sc bearsays %} Well, do you really need to take ownership of the
      <code>Vec</code>? Do you need a <code>Vec</code> in the first place?
    </p>
    <p>What if you want to do this? {% endsc %}</p>
    <pre><code class="language-rust">fn main() {
    let mut a = [1, 2, 3];
    println!(&quot;a = {a:?}&quot;);

    let b = double(a);
    println!(&quot;b = {b:?}&quot;);
}
</code></pre>
    <p>
      Ah yeah, that won't work. Well no I suppose we don't need a
      <code>Vec</code>... after all, we're doing everything in-place, the
      array.. vector.. whatever, container, doesn't need to grow or shrink.
    </p>
    <p>So we can take... OH! A mutable slice:</p>
    <pre><code class="language-rust">fn main() {
    let mut a = [1, 2, 3];
    println!(&quot;a = {a:?}&quot;);

    double(&amp;mut a);
    println!(&quot;a = {a:?}&quot;);
}

fn double(a: &amp;mut [i32]) {
    for x in a.iter_mut() {
        *x *= 2
    }
}
</code></pre>
    <pre><code class="language-shell">$ cargo run -q
a = [1, 2, 3]
a = [2, 4, 6]
</code></pre>
    <p>And let's make sure it works with a <code>Vec</code>, too:</p>
    <pre><code class="language-rust">fn main() {
    let mut a = vec![1, 2, 3];
    println!(&quot;a = {a:?}&quot;);

    double(&amp;mut a);
    println!(&quot;a = {a:?}&quot;);
}
</code></pre>
    <pre><code class="language-shell">$ cargo run -q
a = [1, 2, 3]
a = [2, 4, 6]
</code></pre>
    <p>Yes it does!</p>
    <p>{% sc bearsays %} Okay! It's time... for a quiz.</p>
    <p>Here's a method defined on slices: {% endsc %}</p>
    <pre><code class="language-rust">impl&lt;T&gt; [T] {
    pub const fn first(&amp;self) -&gt; Option&lt;&amp;T&gt; {
        // ...
    }
}
</code></pre>
    <p>{% sc bearsays %} Does it mutate the slice? {% endsc %}</p>
    <p>
      No! It takes an immutable reference (<code>&amp;self</code>), so all it
      does is read.
    </p>
    <p>{% sc bearsays %} Correct! {% endsc %}</p>
    <pre><code class="language-rust">fn main() {
    let a = vec![1, 2, 3];
    dbg!(a.first());
}
</code></pre>
    <pre><code class="language-shell">$ cargo run -q
[src/main.rs:3] a.first() = Some(
    1,
)
</code></pre>
    <p>{% sc bearsays %} What about this one? {% endsc %}</p>
    <pre><code class="language-rust">impl&lt;T&gt; [T] {
    pub fn fill(&amp;mut self, value: T)
    where
        T: Clone,
    {
        // ...
    }
}
</code></pre>
    <p>
      Oh that one mutates! Given the name, I'd say it fills the whole slice with
      <code>value</code>, and... it needs to be able to make clones of the value
      because it might need to repeat it several times.
    </p>
    <p>{% sc bearsays %} Right again! {% endsc %}</p>
    <pre><code class="language-rust">fn main() {
    let mut a = [0u8; 5];
    a.fill(3);
    dbg!(a);
}
</code></pre>
    <pre><code class="language-shell">$ cargo run -q
[src/main.rs:4] a = [
    3,
    3,
    3,
    3,
    3,
]
</code></pre>
    <p>{% sc bearsays %} What about this one? {% endsc %}</p>
    <pre><code class="language-rust">impl&lt;T&gt; [T] {
    pub fn iter(&amp;self) -&gt; Iter&lt;'_, T&gt; {
        // ...
    }
}
</code></pre>
    <p>
      Ooh that one's a toughie. So no mutation, and it uhhh borrows... through?
      I mean we've only briefly seen lifetimes, but I'm assuming we can't mutate
      a thing while we're iterating through it, so like, this:
    </p>
    <pre><code class="language-rust">fn main() {
    let mut a = [1, 2, 3, 4, 5];
    let mut iter = a.iter();
    dbg!(iter.next());
    dbg!(iter.next());
    a[2] = 42;
    dbg!(iter.next());
    dbg!(iter.next());
}
</code></pre>
    <p>...can't possibly work:</p>
    <pre><code class="language-shell">$ cargo run -q
error[E0506]: cannot assign to `a[_]` because it is borrowed
 --&gt; src/main.rs:6:5
  |
3 |     let mut iter = a.iter();
  |                    -------- borrow of `a[_]` occurs here
...
6 |     a[2] = 42;
  |     ^^^^^^^^^ assignment to borrowed `a[_]` occurs here
7 |     dbg!(iter.next());
  |          ----------- borrow later used here

For more information about this error, try `rustc --explain E0506`.
error: could not compile `grr` due to previous error
</code></pre>
    <p>Yeah! Right again 😎</p>
    <p>{% sc bearsays %} Alrighty! Moving on. {% endsc %}</p>
    <h2>Closures</h2>
    <p>{% sc bearsays %} So, remember this code? {% endsc %}</p>
    <pre><code class="language-rust">fn double(a: &amp;[i32]) -&gt; Vec&lt;i32&gt; {
    a.iter().map(|x| x * 2).collect()
}
</code></pre>
    <p>{% sc bearsays %} That's a closure. {% endsc %}</p>
    <p>
      That's a... which part, the pipe-looking thing? <code>|x| x * 2</code>?
    </p>
    <p>{% sc bearsays %} Yes. It's like a function. {% endsc %}</p>
    <p>Wait, no, a function is like this:</p>
    <pre><code class="language-rust">fn main() {
    let a = [1, 2, 3];
    let b = double(&amp;a);
    dbg!(b);
}

// 👇 this
fn times_two(x: &amp;i32) -&gt; i32 {
    x * 2
}

fn double(a: &amp;[i32]) -&gt; Vec&lt;i32&gt; {
    // which we then 👇 use here
    a.iter().map(times_two).collect()
}
</code></pre>
    <pre><code class="language-shell">$ cargo run -q
[src/main.rs:4] b = [
    2,
    4,
    6,
]
</code></pre>
    <p>{% sc bearsays %} Yeah. It does the same thing. {% endsc %}</p>
    <p>Oh, now that you mention it yes, yes it does do the same thing.</p>
    <p>
      {% sc bearsays %} Except a closure can <em>close</em> over its
      environment. {% endsc %}
    </p>
    <p>
      I see. No, wait. I don't. I don't see at all. Its environment? As in the
      birds and the trees and th-
    </p>
    <p>
      {% sc bearsays %} Kinda, except it's more like... bindings. Look: {% endsc
      %}
    </p>
    <pre><code class="language-rust">fn double(a: &amp;[i32]) -&gt; Vec&lt;i32&gt; {
    let factor = 2;
    a.iter().map(|x| x * factor).collect()
}
</code></pre>
    <p>Ohhh. Well that's a constant, it doesn't really count.</p>
    <p>{% sc bearsays %} Fineeee, here: {% endsc %}</p>
    <pre><code class="language-rust">fn main() {
    let a = [1, 2, 3];
    let b = mul(&amp;a, 10);
    dbg!(b);
}

fn mul(a: &amp;[i32], factor: i32) -&gt; Vec&lt;i32&gt; {
    a.iter().map(|x| x * factor).collect()
}
</code></pre>
    <p>
      Okay, okay, I see. So <code>factor</code> is definitely not a constant
      there (if we don't count constant folding), and it's... captured?
    </p>
    <p>{% sc bearsays %} Closed over, yes. {% endsc %}</p>
    <p>
      ...closed over by the closure. I'm gonna say &quot;captured&quot;. Seems
      less obscure.
    </p>
    <p>{% sc bearsays %} Sure, fine. {% endsc %}</p>
    <p>
      Wait wait wait this is boxed trait objects all over again, right? Sort of?
      Because closures are actually fat pointers? One pointer to the function
      itself, and one for the, uh, &quot;environment&quot;. I mean, for
      everything captured by the closure.
    </p>
    <p>
      {% sc bearsays %} Kinda, yes! But aren't we getting ahead of ourselv- {%
      endsc %}
    </p>
    <p>
      No no no, not at all, it doesn't matter that there might be a lot of new
      words, or that the underlying concepts aren't crystal clear to everyone
      reading this yet.
    </p>
    <p>
      What matters is that we can proceed by analogy, because we've seen similar
      fuckery just before, and so we can show an example of a
      <em>manual implementation</em> of closures, just like we did boxed trait
      objects, and that'll clear it up for everyone.
    </p>
    <p>{% sc bearsays %} Are you <em>sure</em> that'll work? {% endsc %}</p>
    <p>Eh, it's worth a shot right?</p>
    <p>
      So here's what I mean. Say we want to provide a function that does
      something three times:
    </p>
    <pre><code class="language-rust">fn main() {
    do_three_times(todo!());
}

fn do_three_times&lt;T&gt;(t: T) {
    todo!()
}
</code></pre>
    <p>
      It's generic, because it can do <em>any</em> thing three times. Caller's
      choice. Only how do I... how does the thing... do... something.
    </p>
    <p>Oh! Traits! I can make a trait, hang on.</p>
    <pre><code class="language-rust">trait Thing {
    fn do_it(&amp;self);
}
</code></pre>
    <p>
      There. And then <code>do_three_times</code> will take anything that
      implements <code>Thing</code>... oh we can use
      <code>impl Trait</code> syntax, no need for explicit generic type
      parameters here:
    </p>
    <pre><code class="language-rust">fn do_three_times(t: impl Thing) {
    for _ in 0..3 {
        t.do_it();
    }
}
</code></pre>
    <p>
      And then to call it, well... we need <em>some</em> type, on which we
      implement <code>Thing</code>, and make it do a thing. What's a good way to
      make up a new type that's empty?
    </p>
    <p>{% sc bearsays %} Empty struct? {% endsc %}</p>
    <p>Right!</p>
    <pre><code class="language-rust">struct Greet;

impl Thing for Greet {
    fn do_it(&amp;self) {
        println!(&quot;hello!&quot;);
    }
}

fn main() {
    do_three_times(Greet);
}
</code></pre>
    <p>And, if my calculations are correct...</p>
    <pre><code class="language-shell">$ cargo run -q
hello!
hello!
hello!
</code></pre>
    <p>Yes!!! See bear? Easy peasy! That wasn't even very long at all.</p>
    <p>{% sc bearsays %} I must admit, I'm impressed. {% endsc %}</p>
    <p>And look, we can even box these!</p>
    <pre><code class="language-rust">trait Thing {
    fn do_it(&amp;self);
}

fn do_three_times(things: &amp;[Box&lt;dyn Thing&gt;]) {
    for _ in 0..3 {
        for t in things {
            t.do_it()
        }
    }
}

struct Greet;

impl Thing for Greet {
    fn do_it(&amp;self) {
        println!(&quot;hello!&quot;);
    }
}

struct Part;

impl Thing for Part {
    fn do_it(&amp;self) {
        println!(&quot;goodbye!&quot;);
    }
}

fn main() {
    do_three_times(&amp;[Box::new(Greet), Box::new(Part)]);
}
</code></pre>
    <pre><code class="language-shell">$ cargo run -q
hello!
goodbye!
hello!
goodbye!
hello!
goodbye!
</code></pre>
    <p>
      {% sc bearsays %} Very nice. You even figured out how to make slices of
      heterogenous types.
    </p>
    <p>Now let's see Paul Allen's trai- {% endsc %}</p>
    <p>
      Let me stop you right there, bear. I know what you're about to ask:
      &quot;Oooh, but what if you need to mutate stuff from inside the closure?
      That won't work will it? Because Wust is such a special widdle wanguage
      uwu, it can't just wet you do the things you want, it has to be a whiny
      baby about it&quot; well HAVE NO FEAR because yes, yes, I have realized
      that this right here:
    </p>
    <pre><code class="language-rust">trait Thing {
    //        👇
    fn do_it(&amp;self);
}
</code></pre>
    <p>...means the closure can <em>never</em> mutate its environment.</p>
    <p>{% sc bearsays %} Ah! {% endsc %}</p>
    <p>
      And so what you'd need to do if you wanted to be able to do that, is have
      a
      <code>ThingMut</code> trait, like so:
    </p>
    <pre><code class="language-rust">trait ThingMut {
    fn do_it(&amp;mut self);
}

fn do_three_times(mut t: impl ThingMut) {
    for _ in 0..3 {
        t.do_it()
    }
}

struct Greet(usize);

impl ThingMut for Greet {
    fn do_it(&amp;mut self) {
        self.0 += 1;
        println!(&quot;hello {}!&quot;, self.0);
    }
}

fn main() {
    do_three_times(Greet(0));
}
</code></pre>
    <pre><code class="language-shell">$ cargo run -q
hello 1!
hello 2!
hello 3!
</code></pre>
    <p>{% sc bearsays %} Yes, but you don't really ne- {% endsc %}</p>
    <p>
      BUT YOU DON'T NEED TO TAKE OWNERSHIP OF THE THINGMUT I know I know, watch
      this:
    </p>
    <pre><code class="language-rust">fn do_three_times(t: &amp;mut dyn ThingMut) {
    for _ in 0..3 {
        t.do_it()
    }
}
</code></pre>
    <p>Boom!</p>
    <pre><code class="language-rust">fn main() {
    do_three_times(&amp;mut Greet(0));
}
</code></pre>
    <p>Bang.</p>
    <p>
      {% sc bearsays %} And I suppose you don't need me to do the link with the
      <em>actual</em> traits in the Rust standard library either? {% endsc %}
    </p>
    <p>Eh, who needs you. I'm sure I can find them... there!</p>
    <p>There's three of them:</p>
    <pre><code class="language-rust">pub trait FnOnce&lt;Args&gt; {
    type Output;
    extern &quot;rust-call&quot; fn call_once(self, args: Args) -&gt; Self::Output;
}

pub trait FnMut&lt;Args&gt;: FnOnce&lt;Args&gt; {
    extern &quot;rust-call&quot; fn call_mut(
        &amp;mut self,
        args: Args
    ) -&gt; Self::Output;
}

pub trait Fn&lt;Args&gt;: FnMut&lt;Args&gt; {
    extern &quot;rust-call&quot; fn call(&amp;self, args: Args) -&gt; Self::Output;
}
</code></pre>
    <p>
      So all <code>Fn</code> (immutable reference) are also
      <code>FnMut</code> (mutable reference), which are also
      <code>FnOnce</code> (takes ownership). Beautiful symmetry.
    </p>
    <p>
      And then... I'm assuming the
      <code>extern &quot;rust-call&quot;</code> fuckery is because... lack of
      <a href="https://en.wikipedia.org/wiki/Variadic_function">variadics</a>
      right now?
    </p>
    <p>
      {% sc bearsays %} Right, yes. And that's also why you can't really
      implement the <code>Fn</code> / <code>FnMut</code> /
      <code>FnOnce</code> traits yourself on arbitrary types right now. {% endsc
      %}
    </p>
    <p>Yeah, see! Easy. So our example becomes this:</p>
    <pre><code class="language-rust">fn do_three_times(t: &amp;mut dyn FnMut()) {
    for _ in 0..3 {
        t()
    }
}

fn main() {
    let mut counter = 0;
    do_three_times(&amp;mut || {
        counter += 1;
        println!(&quot;hello {counter}!&quot;)
    });
}
</code></pre>
    <p>
      Bam, weird syntax but that's a lot less typing, I like it, arguments are
      between pipes, sure why not.
    </p>
    <p>
      {% sc bearsays %} Arguments are between pipes, what do you mean? {% endsc
      %}
    </p>
    <p>
      Oh, well closures can take arguments too, they're just like functions
      right? You told me that. So we can... do this!
    </p>
    <pre><code class="language-rust">//                            👇
fn do_three_times(t: impl Fn(i32)) {
    for i in 0..3 {
        t(i)
    }
}

fn main() {
    //             👇
    do_three_times(|i| println!(&quot;hello {i}!&quot;));
}
</code></pre>
    <p>
      {% sc bearsays %} I see. And I supposed you've figured out boxing as well?
      {% endsc %}
    </p>
    <p>
      The sport, no. But the type erasure, sure, in <em>that</em> regard they're
      just regular traits, so, here we go:
    </p>
    <pre><code class="language-rust">fn do_all_the_things(things: &amp;[Box&lt;dyn Fn()&gt;]) {
    for t in things {
        t()
    }
}

fn main() {
    do_all_the_things(&amp;[
        Box::new(|| println!(&quot;hello&quot;)),
        Box::new(|| println!(&quot;how are you&quot;)),
        Box::new(|| println!(&quot;I wasn't really asking&quot;)),
        Box::new(|| println!(&quot;goodbye&quot;)),
    ]);
}
</code></pre>
    <p>{% sc bearsays %} Well. It looks like you're all set.</p>
    <p>Nothing left to learn.</p>
    <p>The world no longer holds any secrets for you.</p>
    <p>
      Through science, you have rid the universe of its last mystery, and you
      are now cursed to roam, surrounded by the mundane, devoid of the last
      shred of poet- {% endsc %}
    </p>
    <p>Wait, what about async stuff?</p>
    <p>{% sc bearsays %} Ahhhhhhhhhhhhhhhhhhh fuck. {% endsc %}</p>
    <h2>Async stuff</h2>
    <p>
      {% sc bearsays %} Okay, async stuff, is.... ugh. Wait, you've written
      about this before. {% endsc %}
    </p>
    <p>Multiple times yes, but humor me. Why do I want it?</p>
    <p>
      {% sc bearsays %} You don't! God, why would you. I mean, okay you want it
      if you're writing network services and stuff. {% endsc %}
    </p>
    <p>Oh yes, I do want to do that! So I do want async!</p>
    <p>{% sc bearsays %} Yes. Yes you very much want async. {% endsc %}</p>
    <p>And I've heard it makes everything worse!</p>
    <p>
      {% sc bearsays %} Well...... so, you know how if you write a file, it
      writes to the file? {% endsc %}
    </p>
    <p>Yes? Like that:</p>
    <pre><code class="language-rust">fn main() {
    // error handling omitted for story-telling purposes
    let _ = std::fs::write(&quot;/tmp/hi&quot;, &quot;hi!\n&quot;);
}
</code></pre>
    <pre><code class="language-shell">$ cargo run -q &amp;&amp; cat /tmp/hi
hi!
</code></pre>
    <p>
      {% sc bearsays %} Well async is the same, except it doesn't work. {% endsc
      %}
    </p>
    <pre><code class="language-shell">$ cargo add tokio +full
(cut)
</code></pre>
    <pre><code class="language-rust">fn main() {
    // error handling omitted for story-telling purposes
    //        👇 (was `std`)
    let _ = tokio::fs::write(&quot;/tmp/bye&quot;, &quot;bye!\n&quot;);
}
</code></pre>
    <pre><code class="language-shell">$ cargo run -q &amp;&amp; cat /tmp/bye
cat: /tmp/bye: No such file or directory
</code></pre>
    <p>Ah. Indeed it doesn't work.</p>
    <p>{% sc bearsays %} Exactly, it does nothing, zilch: {% endsc %}</p>
    <pre><code class="language-shell">$ cargo b -q &amp;&amp; strace -ff ./target/debug/grr 2&gt;&amp;1 | grep bye
</code></pre>
    <p>
      {% sc bearsays %} When the other clearly did <em>something</em>: {% endsc
      %}
    </p>
    <pre><code class="language-shell">$ cargo b -q &amp;&amp; strace -ff ./target/debug/grr 2&gt;&amp;1 | grep hi
openat(AT_FDCWD, &quot;/tmp/hi&quot;, O_WRONLY|O_CREAT|O_TRUNC|O_CLOEXEC, 0666) = 3
write(3, &quot;hi!\n&quot;, 4)                    = 4
</code></pre>
    <p>
      But wait, that's cuckoo. The cinECMAtic javascript universe also has async
      and it certainly does do things:
    </p>
    <pre><code class="language-javascript">async function main() {
  await require(&quot;fs&quot;).promises.writeFile(&quot;/tmp/see&quot;, &quot;see&quot;);
}

main();
</code></pre>
    <pre><code class="language-shell">$ strace -ff node main.js 2&gt;&amp;1 | grep see
[pid 1825359] openat(AT_FDCWD, &quot;/tmp/see&quot;, O_WRONLY|O_CREAT|O_TRUNC|O_CLOEXEC, 0666 &lt;unfinished ...&gt;
[pid 1825360] write(17, &quot;see&quot;, 3 &lt;unfinished ...&gt;
</code></pre>
    <p>
      {% sc bearsays %} It does do them things, yes. That's because Node.js® is
      <em>very</em> async at its core. See, the idea... well that's unfair but
      let's pretend the idea was &quot;threads are hard okay&quot;. {% endsc %}
    </p>
    <p>
      Sure, I can buy that. Threads seem hard — especially when there's a bunch
      of them stepping on each other's knees and toes, knees and toes.
    </p>
    <p>
      {% sc bearsays %} So fuck threads right? Instead of doing
      <em>blocking</em> calls... {% endsc %}
    </p>
    <p>Wait what are bl-</p>
    <p>
      {% sc bearsays %} calls that, like, block! Block everything. You're
      waiting for... some file to be read, and in the meantime,
      <em>nothing else</em> can happen. {% endsc %}
    </p>
    <p>
      Right. So instead of that we... do callbacks? Those used to be huge right.
    </p>
    <p>
      {% sc bearsays %} Exactly! You say &quot;I'd like to read from that
      file&quot; and say &quot;and when it's done, call me back on this
      number&quot; except it's not a number, it's a closure. {% endsc %}
    </p>
    <p>Right! Like so:</p>
    <pre><code class="language-javascript">const { readFile } = require(&quot;fs&quot;);

readFile(&quot;/usr/bin/gcc&quot;, () =&gt; {
  console.log(&quot;just read /usr/bin/gcc&quot;);
});

readFile(&quot;/usr/bin/clang&quot;, () =&gt; {
  console.log(&quot;just read /usr/bin/clang&quot;);
});
</code></pre>
    <p>
      {% sc bearsays %} Exactly! Even though there's only ever one ECMAScript
      thing happening at once, multiple I/O (input/output) operations can be
      in-flight, and they can complete whenever, which is why if we read this,
      we can get: {% endsc %}
    </p>
    <pre><code class="language-shell">$ node main.js
just read /usr/bin/clang
just read /usr/bin/gcc
</code></pre>
    <p>
      Right! Even though we asked for <code>/usr/bin/gcc</code> to be read
      first.
    </p>
    <p>
      {% sc bearsays %} Exactly. So async Rust is the same, right? Except async
      stuff doesn't run just by itself. There's no built-in runtime that's
      started implicitly, so we gotta create one and use it: {% endsc %}
    </p>
    <pre><code class="language-rust">fn main() {
    tokio::runtime::Runtime::new().unwrap().block_on(async {
        tokio::fs::write(&quot;/tmp/bye&quot;, &quot;bye!\n&quot;).await.unwrap();
    })
}
</code></pre>
    <p>{% sc bearsays %} And now it does do something: {% endsc %}</p>
    <pre><code class="language-shell">$ cargo run -q &amp;&amp; cat /tmp/bye
bye!

$ cargo b -q &amp;&amp; strace -ff ./target/debug/grr 2&gt;&amp;1 | grep bye
[pid 1857097] openat(AT_FDCWD, &quot;/tmp/bye&quot;, O_WRONLY|O_CREAT|O_TRUNC|O_CLOEXEC, 0666) = 9
[pid 1857097] write(9, &quot;bye!\n&quot;, 5)     = 5
</code></pre>
    <p>
      {% sc bearsays %} And so the Node.js® program you showed earlier was doing
      something more like this: {% endsc %}
    </p>
    <pre><code class="language-rust">use std::time::Duration;

fn main() {
    // create a new async runtime
    let rt = tokio::runtime::Runtime::new().unwrap();

    // spawn a future on that runtime
    rt.spawn(async {
        tokio::fs::write(&quot;/tmp/bye&quot;, &quot;bye!\n&quot;).await.unwrap();
    });

    // wait for all spawned futures for... some amount of time
    rt.shutdown_timeout(Duration::from_secs(10_000))
}
</code></pre>
    <p>
      {% sc bearsays %} Except it probably waited for longer than that. But yeah
      that's the idea. {% endsc %}
    </p>
    <p>
      Okay, so, wait, there's async blocks? Like <code>async { stuff }</code>?
    </p>
    <p>{% sc bearsays %} Yes. {% endsc %}</p>
    <p>And async closures? Like <code>async |a, b, c| { stuff }</code>?</p>
    <p>
      {% sc bearsays %} Unfortunately,
      <a href="https://github.com/rust-lang/rust/issues/62290">not yet</a>.
    </p>
    <p>There's async functions, though: {% endsc %}</p>
    <pre><code class="language-rust">use std::time::Duration;

fn main() {
    // create a new async runtime
    let rt = tokio::runtime::Runtime::new().unwrap();

    // spawn a future on that runtime
    //          👇
    rt.spawn(write_bye());

    // wait for all spawned futures for... some amount of time
    rt.shutdown_timeout(Duration::from_secs(10_000))
}

// 👇
async fn write_bye() {
    tokio::fs::write(&quot;/tmp/bye&quot;, &quot;bye!\n&quot;).await.unwrap();
}
</code></pre>
    <p>Well it's <em>something</em>.</p>
    <p>
      But wait, so when you call <code>write_bye()</code> it doesn't actually
      start doing the work?
    </p>
    <p>
      {% sc bearsays %} No, it returns a <em>future</em>, and then you need to
      either spawn it somewhere, or you need to poll it. {% endsc %}
    </p>
    <p>How do, uh... how does one go about polling it?</p>
    <p>{% sc bearsays %} You don't, the runtime does. {% endsc %}</p>
    <p>
      Ah, right. Because of the... no I'm sorry, that's nonsense. The runtime
      polls it?
    </p>
    <p>
      {% sc bearsays %} Well, you can poll it if you want to, sometimes it'll
      even work: {% endsc %}
    </p>
    <pre><code class="language-rust">use std::{
    future::Future,
    task::{Context, RawWaker, RawWakerVTable, Waker},
};

fn main() {
    let fut = tokio::fs::read(&quot;/etc/hosts&quot;);
    let mut fut = Box::pin(fut);

    let rw = RawWaker::new(
        std::ptr::null_mut(),
        &amp;RawWakerVTable::new(clone, wake, wake_by_ref, drop),
    );
    let w = unsafe { Waker::from_raw(rw) };
    let mut cx = Context::from_waker(&amp;w);

    let res = fut.as_mut().poll(&amp;mut cx);
    dbg!(&amp;res);
}

unsafe fn clone(_ptr: *const ()) -&gt; RawWaker {
    todo!()
}

unsafe fn wake(_ptr: *const ()) {
    todo!()
}

unsafe fn wake_by_ref(_ptr: *const ()) {
    todo!()
}

unsafe fn drop(_ptr: *const ()) {
    // do nothing
}
</code></pre>
    <p>Heyyyyyyyyyyyy that's a vtable, we saw this!</p>
    <p>
      {% sc bearsays %} Yes, that's how Rust async runtimes work under the hood.
      And as you can see: {% endsc %}
    </p>
    <pre><code class="language-shell">$ RUST_BACKTRACE=1 cargo run -q
thread 'main' panicked at 'there is no reactor running, must be called from the context of a Tokio 1.x runtime', /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.18.2/src/runtime/context.rs:21:19
stack backtrace:
   0: rust_begin_unwind
             at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/std/src/panicking.rs:584:5
   1: core::panicking::panic_fmt
             at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/core/src/panicking.rs:143:14
   2: core::panicking::panic_display
             at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/core/src/panicking.rs:72:5
   3: tokio::runtime::context::current
             at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.18.2/src/runtime/context.rs:21:19
   4: tokio::runtime::blocking::pool::spawn_blocking
             at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.18.2/src/runtime/blocking/pool.rs:113:14
   5: tokio::fs::asyncify::{{closure}}
             at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.18.2/src/fs/mod.rs:119:11
   6: &lt;core::future::from_generator::GenFuture&lt;T&gt; as core::future::future::Future&gt;::poll
             at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/core/src/future/mod.rs:91:19
   7: tokio::fs::read::read::{{closure}}
             at /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.18.2/src/fs/read.rs:50:42
   8: &lt;core::future::from_generator::GenFuture&lt;T&gt; as core::future::future::Future&gt;::poll
             at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/core/src/future/mod.rs:91:19
   9: grr::main
             at ./src/main.rs:17:15
  10: core::ops::function::FnOnce::call_once
             at /rustc/fe5b13d681f25ee6474be29d748c65adcd91f69e/library/core/src/ops/function.rs:227:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
</code></pre>
    <p>
      {% sc bearsays %} ...okay so this one doesn't work because there's more
      moving pieces than this.
    </p>
    <p>But you get the idea, futures get polled. {% endsc %}</p>
    <p>
      I'm not sure I do. I mean okay so they get polled once, via this weird
      trait:
    </p>
    <pre><code class="language-rust">pub trait Future {
    type Output;
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}
</code></pre>
    <p>
      {% sc bearsays %} Yes, which has a weird
      <code>Pin&lt;&amp;mut Self&gt;</code> receiver instead of say,
      <code>&amp;mut self</code>, to make self-referential types work. {% endsc
      %}
    </p>
    <p>
      Self-referential types? Ok now I'm completely lost. WE TRIED, EVERYONE,
      time to pack up and get outta here.
    </p>
    <p>{% sc bearsays %} No no no bear with me {% endsc %}</p>
    <p>😐</p>
    <p>
      {% sc bearsays %} ...so think back to closures: they're code + data. A
      function and its environment. And the code in there can create new
      references to the data, right? {% endsc %}
    </p>
    <p>I.. I guess?</p>
    <p>{% sc bearsays %} Like this for example: {% endsc %}</p>
    <pre><code class="language-rust">fn main() {
    do_stuff(|| {
        let v = vec![1, 2, 3, 4];
        let back_half = &amp;v[2..];
        println!(&quot;{back_half:?}&quot;);
    });
}

fn do_stuff(f: impl Fn()) {
    f()
}
</code></pre>
    <p>
      Ah right, yes. The closure allocates some memory as a <code>Vec</code>,
      and then it takes an immutable slice of it. I don't see where the issue
      is, though.
    </p>
    <p>
      {% sc bearsays %} Well think of futures like closures but... that you can
      call into several times? {% endsc %}
    </p>
    <p><em>I</em> call into several times?</p>
    <p>{% sc bearsays %} No, the runtime does. {% endsc %}</p>
    <p>... the confusion, it remains.</p>
    <p>{% sc bearsays %} No but like, if we look at this: {% endsc %}</p>
    <pre><code class="language-rust">use std::future::Future;

fn main() {
    do_stuff(async {
        let arr = [1, 2, 3, 4];
        let back_half = &amp;v[2..];
        let hosts = tokio::fs::read(&quot;/etc/hosts&quot;).await;
        println!(&quot;{back_half:?}, {hosts:?}&quot;);
    });
}

fn do_stuff(f: impl Future&lt;Output = ()&gt;) {
    // blah
}
</code></pre>
    <p>Yes, same idea but with some async sprinkled in there.</p>
    <p>
      {% sc bearsays %} Exactly. So that
      <code>read(&quot;/etc/hosts&quot;).await</code> line there, that's an
      <em>await point</em>. {% endsc %}
    </p>
    <p>
      I can't help but feel like we're getting away from the spirit of the
      article, but okay, sure?
    </p>
    <p>
      {% sc bearsays %} Focus! So <code>read()</code> returns a Future, and then
      we call <code>.await</code>, which makes the current/ambient async runtime
      poll it once. {% endsc %}
    </p>
    <p>Sure, I can buy that. And then?</p>
    <p>
      {% sc bearsays %} Well and then either it returns
      <code>Poll::Ready</code> and it <em>synchronously</em> continues execution
      into the second part of that async block. {% endsc %}
    </p>
    <p>Or?</p>
    <p>
      {% sc bearsays %} Or it returns <code>Poll::Pending</code>, at which point
      it'll have already registered itself with all the
      <code>Waker</code> business I teased earlier on. {% endsc %}
    </p>
    <p>Right. And then what happens?</p>
    <p>{% sc bearsays %} And then it returns. {% endsc %}</p>
    <p>
      But... but it can't! If it returns we'll lose the data! The array will go
      out of scope and be freed!
    </p>
    <p>{% sc bearsays %} Exactly. {% endsc %}</p>
    <p>So surely it's not actually returning?</p>
    <p>
      {% sc bearsays %} It <em>is</em> actually returning. But it's also storing
      the array somewhere else. So that the next time it's polled/called, there
      it is. And in that &quot;somewhere else&quot;, it also remembers
      <em>which</em> await point caused it to return <code>Poll::Pending</code>.
      {% endsc %}
    </p>
    <p>So this is all just a gigantic state machine?</p>
    <p>
      {% sc bearsays %} Yes! And some parts of its state (in this case,
      <code>back_half</code>) may reference some other parts of its state (in
      this case, <code>arr</code>), so the state struct itself is...
      self-referential.
    </p>
    <p>
      Here's the async block code again because that's a lot of scrolling: {%
      endsc %}
    </p>
    <pre><code class="language-rust">    do_stuff(async {
        let arr = [1, 2, 3, 4];
        let back_half = &amp;arr[2..];
        let hosts = tokio::fs::read(&quot;/etc/hosts&quot;).await;
        println!(&quot;{back_half:?}, {hosts:?}&quot;);
    });
</code></pre>
    <p>Self-referential as in it refers to itself, gotcha.</p>
    <p>And what's the problem with that?</p>
    <p>
      {% sc bearsays %} The problem is, what if you poll that future once, and
      then it returns <code>Poll::Pending</code>, and then you move it somewhere
      else in memory? {% endsc %}
    </p>
    <p>Then I guess... <code>arr</code> will be moved along with it?</p>
    <p>
      {% sc bearsays %} EXACTLY. And <code>back_half</code> will still point at
      the wrong place. {% endsc %}
    </p>
    <p>Ohhhhhhh so it must be <em>pinned</em>.</p>
    <p>
      {% sc bearsays %} Yes. It must be pinned in order to be polled. That's why
      the receiver of <code>poll</code> is
      <code>Pin&lt;&amp;mut Self&gt;</code>. {% endsc %}
    </p>
    <p>
      And so we can move the future before it's polled, but after the first time
      it's been polled, it's game over? Stay pinned?
    </p>
    <p>
      {% sc bearsays %} Unless it implements <code>Unpin</code>, yes. {% endsc
      %}
    </p>
    <p>Which... it would implement only if... it was safe to move elsewhere?</p>
    <p>
      {% sc bearsays %} Yes, for example if it only contained references to
      memory that's on the heap!
    </p>
    <p>
      But <code>GenFuture</code>, the opaque type of async blocks, never
      implements <code>Unpin</code> (at least, I couldn't get it to), so this
      fails to build: {% endsc %}
    </p>
    <pre><code class="language-rust">use std::{future::Future, time::Duration};

fn main() {
    let fut = async move {
        println!(&quot;hang on a sec...&quot;);
        tokio::time::sleep(Duration::from_secs(1)).await;
        println!(&quot;I'm here!&quot;);
    };
    ensure_unpin(&amp;fut);
}

fn ensure_unpin&lt;F: Future + Unpin&gt;(f: &amp;F) {
    // muffin
}
</code></pre>
    <pre><code class="language-shell">$ cargo check -q
error[E0277]: `from_generator::GenFuture&lt;[static generator@src/main.rs:4:26: 8:6]&gt;` cannot be unpinned
  --&gt; src/main.rs:9:18
   |
9  |     ensure_unpin(&amp;fut);
   |     ------------ ^^^^ within `impl Future&lt;Output = ()&gt;`, the trait `Unpin` is not implemented for `from_generator::GenFuture&lt;[static generator@src/main.rs:4:26: 8:6]&gt;`
   |     |
   |     required by a bound introduced by this call
</code></pre>
    <p>
      {% sc bearsays %} ...but we can always &quot;box-pin&quot; it, moving the
      <em>whole</em> future to the heap, so that we can move
      <em>a reference to it</em> wherever we please: {% endsc %}
    </p>
    <pre><code class="language-rust">use std::{future::Future, time::Duration};

fn main() {
    //           👇
    let fut = Box::pin(async move {
        println!(&quot;hang on a sec...&quot;);
        tokio::time::sleep(Duration::from_secs(1)).await;
        println!(&quot;I'm here!&quot;);
    });
    ensure_unpin(&amp;fut);
}

fn ensure_unpin&lt;F: Future + Unpin&gt;(f: &amp;F) {
    // muffin
}
</code></pre>
    <p>Okay that... that was a lot to take in.</p>
    <p>So async stuff is awful because I need to understand all that, right?</p>
    <p>{% sc bearsays %} Oh no, not at all. {% endsc %}</p>
    <p>Huh?</p>
    <p>
      {% sc bearsays %} For starters, you don't really want to build a tokio
      Runtime yourself. There's macros for that. {% endsc %}
    </p>
    <pre><code class="language-rust">#[tokio::main]
async fn main() {
    tokio::fs::write(&quot;/tmp/bye&quot;, &quot;bye!\n&quot;).await.unwrap();
}
</code></pre>
    <p>Ah, that seems more convenient, yes.</p>
    <p>
      {% sc bearsays %} And you never really want to care about the
      <code>Context</code> / <code>Waker</code> / <code>RawWaker</code> stuff
      either. Those are implementation details. {% endsc %}
    </p>
    <p>Right right, yes.</p>
    <p>
      {% sc bearsays %} But thus is the terrible deal we've made with the
      ~~devil~~ compiler. It guards us from numerous perils, but in exchange, we
      sometimes run head-first into unholy type errors. {% endsc %}
    </p>
    <p>
      I see. So you're saying... I don't <em>need</em> to understand pinning for
      example?
    </p>
    <p>
      {% sc bearsays %} No! You just need to know that you can
      <code>Box::pin()</code> your way out of &quot;this thing is not
      <code>Unpin</code>&quot; diagnostics. Just like you can
      <code>.clone()</code> your way out of many &quot;this thing doesn't live
      long enough&quot;. {% endsc %}
    </p>
    <p>Then WHY in the world did we learn all that.</p>
    <p>
      {% sc bearsays %} Well, if you have a vague understanding of the
      underlying design constraints, it makes it a teensy bit less frustrating
      when you run into seemingly arbitrary limitations. {% endsc %}
    </p>
    <p>Such as?</p>
    <p>{% sc bearsays %} Ah, friend.</p>
    <p>I'm so glad you asked. {% endsc %}</p>
    <h2>Async trait methods</h2>
    <p>
      {% sc bearsays %} So traits! You know traits. Here's a trait. {% endsc %}
    </p>
    <pre><code class="language-rust">pub trait Read {
    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize&gt;;

    // (other methods omitted)
}
</code></pre>
    <p>
      Yeah I know traits. That seems like a reasonable trait. The receiver is
      <code>&amp;mut self</code>, because... it advances a read head? Also takes
      a buffer to write its output to, and returns how many bytes were read.
      Pretty simple stuff.
    </p>
    <p>
      {% sc bearsays %} Wonderful! Now do the same, but make
      <code>read</code> async. {% endsc %}
    </p>
    <p>What, like that?</p>
    <pre><code class="language-rust">pub trait AsyncRead {
    async fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize, Box&lt;dyn std::error::Error&gt;&gt;;
}
</code></pre>
    <pre><code class="language-shell">$ cargo check -q
error[E0706]: functions in traits cannot be declared `async`
 --&gt; src/main.rs:2:5
  |
2 |     async fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Result&lt;usize, Box&lt;dyn std::error::Error&gt;&gt;;
  |     -----^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  |     |
  |     `async` because of this
  |
  = note: `async` trait functions are not currently supported
  = note: consider using the `async-trait` crate: https://crates.io/crates/async-trait
</code></pre>
    <p>
      Well the diagnostic is exemplary but, long story short: compiler says no.
    </p>
    <p>{% sc bearsays %} Exactly. Do you know why? {% endsc %}</p>
    <p>Not really no?</p>
    <p>
      {% sc bearsays %} Well, it's complicated. But we can sorta get an
      intuition for it.
    </p>
    <p>
      Turns out there already <em>is</em> an <code>AsyncRead</code> trait in
      <code>tokio</code> (and a couple other places). Let's make an async
      function that just calls it: {% endsc %}
    </p>
    <pre><code class="language-rust">async fn read(r: &amp;mut (dyn AsyncRead + Unpin), buf: &amp;mut [u8]) -&gt; std::io::Result&lt;usize&gt; {
    r.read(buf).await
}
</code></pre>
    <p>{% sc bearsays %} And now let's use it a couple times: {% endsc %}</p>
    <pre><code class="language-rust">use tokio::{
    fs::File,
    io::{AsyncRead, AsyncReadExt, AsyncWriteExt},
    net::TcpStream,
};

#[tokio::main]
async fn main() {
    let mut f = File::open(&quot;/etc/hosts&quot;).await.unwrap();
    let mut buf1 = vec![0u8; 128];
    read(&amp;mut f, &amp;mut buf1).await.unwrap();
    println!(&quot;buf1 = {:?}&quot;, std::str::from_utf8(&amp;buf1));

    let mut s = TcpStream::connect(&quot;example.org:80&quot;).await.unwrap();
    s.write_all(&quot;GET http://example.org HTTP/1.1\r\n\r\n&quot;.as_bytes())
        .await
        .unwrap();
    let mut buf2 = vec![0u8; 128];
    read(&amp;mut s, &amp;mut buf2).await.unwrap();
    println!(&quot;buf2 = {:?}&quot;, std::str::from_utf8(&amp;buf2));
}

async fn read(r: &amp;mut (dyn AsyncRead + Unpin), buf: &amp;mut [u8]) -&gt; std::io::Result&lt;usize&gt; {
    r.read(buf).await
}
</code></pre>
    <p>Whoa. WHOA, we're writing real code now?</p>
    <p>
      {% sc bearsays %} If you call that real code, sure. Anyway we're doing two
      asynchronous things: reading from a file, and reading from a TCP socket,
      cosplaying as the world's worst HTTP client. {% endsc %}
    </p>
    <pre><code class="language-shell">$ cargo run -q
buf1 = Ok(&quot;127.0.0.1\tlocalhost\n127.0.1.1\tamos\n\n# The following lines are desirable for IPv6 capable hosts\n::1     ip6-localhost ip6-loopbac&quot;)
buf2 = Ok(&quot;HTTP/1.1 200 OK\r\nAge: 586436\r\nCache-Control: max-age=604800\r\nContent-Type: text/html; charset=UTF-8\r\nDate: Wed, 01 Jun 2022 17:1&quot;)
</code></pre>
    <p>
      {% sc bearsays %} Now here's my question: what type does
      <code>read</code> return? {% endsc %}
    </p>
    <p>Our <code>read</code> function? I have no idea, why?</p>
    <p>{% sc bearsays %} Because, it's important. {% endsc %}</p>
    <p>Well... I suppose we could try assigning one to the other?</p>
    <p>{% sc bearsays %} Sure, let's do that. {% endsc %}</p>
    <pre><code class="language-rust">use tokio::{
    fs::File,
    io::{AsyncRead, AsyncReadExt, AsyncWriteExt},
    net::TcpStream,
};

#[tokio::main]
async fn main() {
    let mut f = File::open(&quot;/etc/hosts&quot;).await.unwrap();
    let mut buf1 = vec![0u8; 128];

    let mut s = TcpStream::connect(&quot;example.org:80&quot;).await.unwrap();
    s.write_all(&quot;GET http://example.org HTTP/1.1\r\n\r\n&quot;.as_bytes())
        .await
        .unwrap();
    let mut buf2 = vec![0u8; 128];

    #[allow(unused_assignments)]
    let mut fut1 = read(&amp;mut f, &amp;mut buf1);
    let fut2 = read(&amp;mut s, &amp;mut buf2);
    fut1 = fut2;
    fut1.await.unwrap();
    println!(&quot;buf2 = {:?}&quot;, std::str::from_utf8(&amp;buf2));
}

async fn read(r: &amp;mut (dyn AsyncRead + Unpin), buf: &amp;mut [u8]) -&gt; std::io::Result&lt;usize&gt; {
    r.read(buf).await
}
</code></pre>
    <pre><code class="language-shell">$ cargo run -q
buf2 = Ok(&quot;HTTP/1.1 200 OK\r\nAge: 387619\r\nCache-Control: max-age=604800\r\nContent-Type: text/html; charset=UTF-8\r\nDate: Wed, 01 Jun 2022 17:2&quot;)
</code></pre>
    <p>Hey, that worked!</p>
    <p>
      {% sc bearsays %} Yes indeed. What else can you tell me about those types?
      {% endsc %}
    </p>
    <p>Mhhh their names, sort of?</p>
    <pre><code class="language-rust">{
    // in main:

    let fut1 = read(&amp;mut f, &amp;mut buf1);
    let fut2 = read(&amp;mut s, &amp;mut buf2);
    println!(&quot;fut1's type is {}&quot;, type_name_of_val(&amp;fut1));
    println!(&quot;fut2's type is {}&quot;, type_name_of_val(&amp;fut2));
}

fn type_name_of_val&lt;T&gt;(_t: &amp;T) -&gt; &amp;'static str {
    std::any::type_name::&lt;T&gt;()
}
</code></pre>
    <pre><code class="language-shell">$ cargo run -q
fut1's type is core::future::from_generator::GenFuture&lt;grr::read::{{closure}}&gt;
fut2's type is core::future::from_generator::GenFuture&lt;grr::read::{{closure}}&gt;
</code></pre>
    <p>Hah! It's closures all the way down. And then I guess their size?</p>
    <pre><code class="language-rust">    println!(&quot;fut1's size is {}&quot;, std::mem::size_of_val(&amp;fut1));
    println!(&quot;fut2's size is {}&quot;, std::mem::size_of_val(&amp;fut2));
</code></pre>
    <pre><code class="language-shell">$ cargo run -q
fut1's size is 72
fut2's size is 72
</code></pre>
    <p>
      {% sc bearsays %} Okay, very well! Now same question with this
      <code>read</code> function: {% endsc %}
    </p>
    <pre><code class="language-rust">async fn read(mut r: (impl AsyncRead + Unpin), buf: &amp;mut [u8]) -&gt; std::io::Result&lt;usize&gt; {
    r.read(buf).await
}
</code></pre>
    <p>Okay, let's try assigning one to the other...</p>
    <pre><code class="language-rust">    let mut fut1 = read(&amp;mut f, &amp;mut buf1);
    let fut2 = read(&amp;mut s, &amp;mut buf2);
    fut1 = fut2;
</code></pre>
    <pre><code class="language-shell">$ cargo run -q
error[E0308]: mismatched types
  --&gt; src/main.rs:20:12
   |
18 |     let mut fut1 = read(&amp;mut f, &amp;mut buf1);
   |                    ----------------------- expected due to this value
19 |     let fut2 = read(&amp;mut s, &amp;mut buf2);
20 |     fut1 = fut2;
   |            ^^^^ expected struct `tokio::fs::File`, found struct `tokio::net::TcpStream`
   |
note: while checking the return type of the `async fn`
  --&gt; src/main.rs:25:67
   |
25 | async fn read(mut r: (impl AsyncRead + Unpin), buf: &amp;mut [u8]) -&gt; std::io::Result&lt;usize&gt; {
   |                                                                   ^^^^^^^^^^^^^^^^^^^^^^ checked the `Output` of this `async fn`, expected opaque type
note: while checking the return type of the `async fn`
  --&gt; src/main.rs:25:67
   |
25 | async fn read(mut r: (impl AsyncRead + Unpin), buf: &amp;mut [u8]) -&gt; std::io::Result&lt;usize&gt; {
   |                                                                   ^^^^^^^^^^^^^^^^^^^^^^ checked the `Output` of this `async fn`, found opaque type
   = note: expected opaque type `impl Future&lt;Output = Result&lt;usize, std::io::Error&gt;&gt;` (struct `tokio::fs::File`)
              found opaque type `impl Future&lt;Output = Result&lt;usize, std::io::Error&gt;&gt;` (struct `tokio::net::TcpStream`)
   = help: consider `await`ing on both `Future`s

For more information about this error, try `rustc --explain E0308`.
error: could not compile `grr` due to previous error
</code></pre>
    <p>
      Huh. HUH. The compiler is not happy AT ALL. It's trying
      <em>very hard</em> to be helpful, but it's clear it didn't expect anyone
      to fuck around in that particular manner, much less find out.
    </p>
    <p>
      Let's try answering the other questions though... the type
      &quot;name&quot;:
    </p>
    <pre><code class="language-rust">    let fut1 = read(&amp;mut f, &amp;mut buf1);
    let fut2 = read(&amp;mut s, &amp;mut buf2);
    println!(&quot;fut1's name is {}&quot;, type_name_of_val(&amp;fut1));
    println!(&quot;fut2's name is {}&quot;, type_name_of_val(&amp;fut2));
</code></pre>
    <pre><code class="language-shell">$ cargo run -q
fut1's name is core::future::from_generator::GenFuture&lt;grr::read&lt;&amp;mut tokio::fs::file::File&gt;::{{closure}}&gt;
fut2's name is core::future::from_generator::GenFuture&lt;grr::read&lt;&amp;mut tokio::net::tcp::stream::TcpStream&gt;::{{closure}}&gt;
</code></pre>
    <p>Ooooh interesting. And then their sizes:</p>
    <pre><code class="language-rust">    let fut1 = read(&amp;mut f, &amp;mut buf1);
    let fut2 = read(&amp;mut s, &amp;mut buf2);
    println!(&quot;fut1's size is {}&quot;, std::mem::size_of_val(&amp;fut1));
    println!(&quot;fut2's size is {}&quot;, std::mem::size_of_val(&amp;fut2));
</code></pre>
    <pre><code class="language-shell">$ cargo run -q
fut1's size is 64
fut2's size is 64
</code></pre>
    <p>
      Awwwwwww I was hoping for them to be different, b- wait, WAIT, we're
      passing
      <code>&amp;mut f</code> and <code>&amp;mut s</code> each time, that's 8
      bytes each, if we pass ownership of the <code>File</code> /
      <code>TcpStream</code> respectively, then maybe...
    </p>
    <pre><code class="language-rust">    let fut1 = read(f, &amp;mut buf1);
    let fut2 = read(s, &amp;mut buf2);
    println!(&quot;fut1's size is {}&quot;, std::mem::size_of_val(&amp;fut1));
    println!(&quot;fut2's size is {}&quot;, std::mem::size_of_val(&amp;fut2));
</code></pre>
    <pre><code class="language-shell">$ cargo run -q
fut1's size is 256
fut2's size is 112
</code></pre>
    <p>YES! The <code>File</code> is bigger.</p>
    <p>
      {% sc bearsays %} Yes it is, for some reason. I can see... a
      <code>tokio::sync::Mutex</code> in there? Fun!
    </p>
    <p>
      Okay so, is <code>read</code> returning the same type in both cases? {%
      endsc %}
    </p>
    <p>No!</p>
    <p>{% sc bearsays %} And how would that work in a trait? {% endsc %}</p>
    <p>
      Well... we have <code>impl Trait</code> in return position, right? So just
      like these:
    </p>
    <pre><code class="language-rust">async fn sleepy_times() {
    tokio::time::sleep(Duration::from_secs(1)).await
}
</code></pre>
    <p>...are actually sugar for these:</p>
    <pre><code class="language-rust">fn sleepy_times() -&gt; impl Future&lt;Output = ()&gt; {
    async { tokio::time::sleep(Duration::from_secs(1)).await }
}
</code></pre>
    <p>Then I guess instead of this:</p>
    <pre><code class="language-rust">trait AsyncRead {
    async fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; std::io::Result&lt;usize&gt;;
}
</code></pre>
    <p>We can have this:</p>
    <pre><code class="language-rust">trait AsyncRead {
    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; impl Future&lt;Output = std::io::Result&lt;usize&gt;&gt;;
}
</code></pre>
    <p>{% sc bearsays %} You would think so! Except we cannot. {% endsc %}</p>
    <pre><code class="language-shell">$ cargo run -q
error[E0562]: `impl Trait` only allowed in function and inherent method return types, not in trait method return
 --&gt; src/main.rs:9:43
  |
9 |     fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; impl Future&lt;Output = std::io::Result&lt;usize&gt;&gt;;
  |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0562`.
error: could not compile `grr` due to previous error
</code></pre>
    <p>Well THAT'S IT. I'm learning Haskell.</p>
    <p>
      {% sc bearsays %} Whoa whoa now's not the time for self-harm. It's just a
      limitation!
    </p>
    <p>On the other hand, we can have that: {% endsc %}</p>
    <pre><code class="language-rust">trait AsyncRead {
    type Future: Future&lt;Output = std::io::Result&lt;usize&gt;&gt;;

    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Self::Future;
}
</code></pre>
    <p>
      {% sc bearsays %} And <code>AsyncRead::Future</code> is an
      <em>associated type</em>. It's chosen by the implementor of the trait. {%
      endsc %}
    </p>
    <p>I swear to glob, bear, if this is another one of your tricks, I'm..</p>
    <pre><code class="language-shell">$ cargo check -q
(nothing)
</code></pre>
    <p>Oh. No, this checks. (Literally)</p>
    <p>What's the catch?</p>
    <p>{% sc bearsays %} Try implementing it! {% endsc %}</p>
    <p>
      Alright, well there's... tokio has its own <code>AsyncRead</code> trait...
      and then an <code>AsyncReadExt</code> extension trait, which actually
      gives us <code>read</code>, so we can just.. and then we... okay, there it
      is:
    </p>
    <pre><code class="language-rust">impl AsyncRead for File {
    type Future = ();

    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Self::Future {
        tokio::io::AsyncReadExt::read(self, buf)
    }
}
</code></pre>
    <p>But umm. What do I put as the <code>Future</code> type...</p>
    <p>{% sc bearsays %} Hahahahahahahha. {% endsc %}</p>
    <p>Oh shut up will you. I'm sure the compiler will be able to help:</p>
    <pre><code class="language-shell">$ cargo check -q
error[E0277]: `()` is not a future
  --&gt; src/main.rs:17:19
   |
17 |     type Future = ();
   |                   ^^ `()` is not a future
   |
   = help: the trait `Future` is not implemented for `()`
   = note: () must be a future or must implement `IntoFuture` to be awaited
note: required by a bound in `AsyncRead::Future`
  --&gt; src/main.rs:11:18
   |
11 |     type Future: Future&lt;Output = std::io::Result&lt;usize&gt;&gt;;
   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `AsyncRead::Future`

error[E0308]: mismatched types
  --&gt; src/main.rs:20:9
   |
19 |     fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Self::Future {
   |                                           ------------ expected `()` because of return type
20 |         tokio::io::AsyncReadExt::read(self, buf)
   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: consider using a semicolon here: `;`
   |         |
   |         expected `()`, found struct `tokio::io::util::read::Read`
   |
   = note: expected unit type `()`
                 found struct `tokio::io::util::read::Read&lt;'_, tokio::fs::File&gt;`

Some errors have detailed explanations: E0277, E0308.
For more information about an error, try `rustc --explain E0277`.
error: could not compile `grr` due to 2 previous errors
</code></pre>
    <p>See! I just have to...</p>
    <pre><code class="language-rust">impl AsyncRead for File {
    type Future = tokio::io::util::read::Read&lt;'_, tokio::fs::File&gt;;

    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Self::Future {
        tokio::io::AsyncReadExt::read(self, buf)
    }
}
</code></pre>
    <pre><code class="language-shell">$ cargo check -q
error[E0603]: module `util` is private
   --&gt; src/main.rs:17:30
    |
17  |     type Future = tokio::io::util::read::Read&lt;'_, tokio::fs::File&gt;;
    |                              ^^^^ private module
    |
note: the module `util` is defined here
   --&gt; /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/tokio-1.18.2/src/io/mod.rs:256:5
    |
256 |     pub(crate) mod util;
    |     ^^^^^^^^^^^^^^^^^^^^
</code></pre>
    <p>😭</p>
    <p>
      {% sc bearsays %} Hahahahahha. You simultaneously had the best and the
      worst luck. {% endsc %}
    </p>
    <p>...explain?</p>
    <p>
      {% sc bearsays %} Well, because it turns out that
      <code>AsyncReadExt::read</code> is not an <code>async fn</code>, it's a
      regular fn that returns a <em>named</em> type that implements
      <code>Future</code>, so you <em>could</em> technically implement your
      <code>AsyncRead</code> trait... but it's unexported, so <em>you</em> can't
      name it, only the <code>tokio</code> crate can. {% endsc %}
    </p>
    <p>Ahhhhhhhhhh. So... how do I get out of this?</p>
    <p>
      {% sc bearsays %} Remember the survival rules: you could always
      <code>Box::pin</code> the future. That way you can name it. {% endsc %}
    </p>
    <p>Okay... then the whole thing becomes this:</p>
    <pre><code class="language-rust">trait AsyncRead {
    type Future: Future&lt;Output = std::io::Result&lt;usize&gt;&gt;;

    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Self::Future;
}

impl AsyncRead for File {
    type Future = Pin&lt;Box&lt;dyn Future&lt;Output = std::io::Result&lt;usize&gt;&gt;&gt;&gt;;

    fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Self::Future {
        Box::pin(tokio::io::AsyncReadExt::read(self, buf))
    }
}
</code></pre>
    <p>...which seems like it just.. might..</p>
    <pre><code class="language-shell">$ cargo check -q
error[E0759]: `buf` has an anonymous lifetime `'_` but it needs to satisfy a `'static` lifetime requirement
  --&gt; src/main.rs:20:18
   |
19 |     fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Self::Future {
   |                             --------- this data with an anonymous lifetime `'_`...
20 |         Box::pin(tokio::io::AsyncReadExt::read(self, buf))
   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^---^
   |                                                      |
   |                                                      ...is used and required to live as long as `'static` here
   |
note: `'static` lifetime requirement introduced by the return type
  --&gt; src/main.rs:19:43
   |
19 |     fn read(&amp;mut self, buf: &amp;mut [u8]) -&gt; Self::Future {
   |                                           ^^^^^^^^^^^^ requirement introduced by this return type
20 |         Box::pin(tokio::io::AsyncReadExt::read(self, buf))
   |         -------------------------------------------------- because of this returned expression

For more information about this error, try `rustc --explain E0759`.
error: could not compile `grr` due to previous error
</code></pre>
    <p>Oh COME ON.</p>
    <p>
      {% sc bearsays %} Hahahahahahahahahhahah yes. The
      <code>Self::Future</code> type has to be generic over the lifetime of
      self... {% endsc %}
    </p>
    <p>
      ??? how did we get here. We were learning some basic Rust. It was nice.
    </p>
    <p>
      {% sc bearsays %} Well, <code>Box&lt;dyn Trait&gt;</code> actually has an
      implicit static bound: it's really
      <code>Box&lt;dyn Trait + 'static&gt;</code>. {% endsc %}
    </p>
    <p>It... okay yes, it must be owned.</p>
    <p>
      {% sc bearsays %} And the future you're trying to box isn't owned is it?
      It's borrowing from <code>self</code>. {% endsc %}
    </p>
    <p>Ahhhh fuckity fuck fuck.</p>
    <p>
      {% sc bearsays %} Hey hey hey, no cursing, it's nothing a few nightly
      features can't fix! {% endsc %}
    </p>
    <pre><code class="language-toml"># in rust-toolchain.toml

[toolchain]
channel = &quot;nightly-2022-06-01&quot;
</code></pre>
    <pre><code class="language-rust">//                   👇
#![feature(generic_associated_types)]

use std::{future::Future, pin::Pin};
use tokio::fs::File;

#[tokio::main]
async fn main() {
    let mut f = File::open(&quot;/etc/hosts&quot;).await.unwrap();
    let mut buf = vec![0u8; 32];
    AsyncRead::read(&amp;mut f, &amp;mut buf).await.unwrap();
    println!(&quot;buf = {:?}&quot;, std::str::from_utf8(&amp;buf));
}

trait AsyncRead {
    type Future&lt;'a&gt;: Future&lt;Output = std::io::Result&lt;usize&gt;&gt;
    where
        Self: 'a;

    fn read&lt;'a&gt;(&amp;'a mut self, buf: &amp;'a mut [u8]) -&gt; Self::Future&lt;'a&gt;;
}

impl AsyncRead for File {
    type Future&lt;'a&gt; = Pin&lt;Box&lt;dyn Future&lt;Output = std::io::Result&lt;usize&gt;&gt; + 'a&gt;&gt;;

    fn read&lt;'a&gt;(&amp;'a mut self, buf: &amp;'a mut [u8]) -&gt; Self::Future&lt;'a&gt; {
        Box::pin(tokio::io::AsyncReadExt::read(self, buf))
    }
}
</code></pre>
    <p>Whoa whoa whoa when did we graduate to that level of type fuckery.</p>
    <p>
      {% sc bearsays %} Just squint! Or come back to it every couple weeks,
      whichever works. {% endsc %}
    </p>
    <pre><code class="language-shell">$ cargo run -q
buf = Ok(&quot;127.0.0.1\tlocalhost\n127.0.1.1\tam&quot;)
</code></pre>
    <p>Well it does run, I'll grant you that.</p>
    <p>
      But wait, isn't boxing bad? What if we don't want to move that future to
      the heap?
    </p>
    <p>
      {% sc bearsays %} Ah, then we need another ~~trick~~ unstable feature. And
      look, we can even use an <code>async</code> block! {% endsc %}
    </p>
    <pre><code class="language-rust">//                   👇
#![feature(generic_associated_types)]
//                   👇👇
#![feature(type_alias_impl_trait)]

use std::future::Future;
use tokio::fs::File;

#[tokio::main]
async fn main() {
    let mut f = File::open(&quot;/etc/hosts&quot;).await.unwrap();
    let mut buf = vec![0u8; 32];
    AsyncRead::read(&amp;mut f, &amp;mut buf).await.unwrap();
    println!(&quot;buf = {:?}&quot;, std::str::from_utf8(&amp;buf));
}

trait AsyncRead {
    type Future&lt;'a&gt;: Future&lt;Output = std::io::Result&lt;usize&gt;&gt;
    where
        Self: 'a;

    fn read&lt;'a&gt;(&amp;'a mut self, buf: &amp;'a mut [u8]) -&gt; Self::Future&lt;'a&gt;;
}

impl AsyncRead for File {
    //                 👇
    type Future&lt;'a&gt; = impl Future&lt;Output = std::io::Result&lt;usize&gt;&gt; + 'a;

    fn read&lt;'a&gt;(&amp;'a mut self, buf: &amp;'a mut [u8]) -&gt; Self::Future&lt;'a&gt; {
        // 👇
        async move { tokio::io::AsyncReadExt::read(self, buf).await }
    }
}
</code></pre>
    <p>Whoaaaaa. It even runs!</p>
    <p>{% sc bearsays %} It does! And you know the best part? {% endsc %}</p>
    <p>No?</p>
    <p>
      {% sc bearsays %} These are actually slated for stabilizations Soon™️. {%
      endsc %}
    </p>
    <p>Wait, so we're learning all that for naught? All that effort???</p>
    <p>
      {% sc bearsays %} Eh, look at this way: if and when those get stabilized,
      we'll be able to look back at all and laugh.
    </p>
    <p>
      Just like today laugh at the fact that before
      <a href="https://blog.rust-lang.org/2019/05/23/Rust-1.35.0.html"
        >Rust 1.35</a
      >
      (May 2019), the <code>Fn</code> traits weren't implemented for
      <code>Box&lt;dyn Fn&gt;</code>.
    </p>
    <p>
      Or any number of significant milestones. It's been a long road. {% endsc
      %}
    </p>
    <p>I see. And in the meantime?</p>
    <p>
      {% sc bearsays %} In the meantime my dear, we live in the now. And in the
      now, we have to deal with things such as... {% endsc %}
    </p>
    <h2>The Connect trait from hyper</h2>
    <p>
      Ah, <a href="https://docs.rs/hyper/latest/hyper/">hyper</a>! I've heard of
      it before.
    </p>
    <p>
      It's a... http library? Does client, server, even http/2, maybe some day
      http/3.
    </p>
    <p>
      {% sc bearsays %} Yeah I uh... that one needs help still. Call me? I just
      want to help.
    </p>
    <p>But yes, http stuff. {% endsc %}</p>
    <p>And it has a <code>Connect</code> trait which is...</p>
    <pre><code class="language-rust">pub trait Connect: Sealed + Sized { }
</code></pre>
    <p>...not very helpful.</p>
    <p>
      {% sc bearsays %} No. But if you bothered to read the docs, you'd realize
      you're not supposed to implement it directly: instead you should implement
      <code>tower::Service&lt;Uri&gt;</code>. {% endsc %}
    </p>
    <p>
      Oh boy, here we go. How about I don't implement it at all? Huh? How's
      that.
    </p>
    <p>{% sc bearsays %} Sure, you don't need to! {% endsc %}</p>
    <pre><code class="language-shell"># let's just switch back to stable...
$ rm rust-toolchain.toml

$ cargo add hyper --features full
(cut)
</code></pre>
    <pre><code class="language-rust">use hyper::Client;

#[tokio::main]
async fn main() {
    let client = Client::new();
    let uri = &quot;http://example.org&quot;.parse().unwrap();
    let res = client.get(uri).await.unwrap();
    let body = hyper::body::to_bytes(res.into_body()).await.unwrap();
    let body = std::str::from_utf8(&amp;body).unwrap();
    println!(&quot;{}...&quot;, &amp;body[..128]);
}
</code></pre>
    <pre><code class="language-shell">$ cargo run -q
&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Example Domain&lt;/title&gt;

    &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;meta http-equiv=&quot;Content-type...
</code></pre>
    <p>
      Ah, well, that's good. Cause I'm done with gnarly traits. Only simple code
      from now on.
    </p>
    <p>
      {% sc bearsays %} And you're absolutely entitled to that. So that's for a
      simple plaintext HTTP request over TCP, but did you know you can do HTTP
      over other types of sockets?
    </p>
    <p>Unix sockets for instance! {% endsc %}</p>
    <p>Unix sock... oh like the Docker daemon?</p>
    <p>{% sc bearsays %} Exactly like the Docker daemon! {% endsc %}</p>
    <pre><code class="language-shell">$ cargo add hyperlocal
(cut)

$ cargo add serde_json
(cut)
</code></pre>
    <pre><code class="language-rust">use hyper::{Body, Client};
use hyperlocal::UnixConnector;

#[tokio::main]
async fn main() {
    let client = Client::builder().build::&lt;_, Body&gt;(UnixConnector);
    let uri = hyperlocal::Uri::new(&quot;/var/run/docker.sock&quot;, &quot;/v1.41/info&quot;).into();
    let res = client.get(uri).await.unwrap();
    let body = hyper::body::to_bytes(res.into_body()).await.unwrap();
    let value: serde_json::Value = serde_json::from_slice(&amp;body).unwrap();
    println!(&quot;operating system: {}&quot;, value[&quot;OperatingSystem&quot;]);
}
</code></pre>
    <pre><code class="language-shell">$ cargo run -q
operating system: &quot;Ubuntu 22.04 LTS&quot;
</code></pre>
    <p>Whoa wait, <code>serde_json</code>? Are we doing useful stuff again?</p>
    <p>{% sc bearsays %} Just for a bit.</p>
    <p>
      So, making a request like that involves a bunch of operations, right? {%
      endsc %}
    </p>
    <p>
      Yeah it does! Let's take a look with <code>strace</code>, since
      <em>apparently</em> that's fair game in this monstrous article:
    </p>
    <pre><code class="language-shell">$ cargo build -q &amp;&amp; strace -ff ./target/debug/grr 2&gt;&amp;1 | grep -vE 'futex|mmap|munmap|madvise|mprotect|sigalt|sigproc|prctl' | grep connect -A 20
[pid 1943976] connect(9, {sa_family=AF_UNIX, sun_path=&quot;/var/run/docker.sock&quot;}, 23 &lt;unfinished ...&gt;
[pid 1943976] &lt;... connect resumed&gt;)    = 0
[pid 1943976] epoll_ctl(5, EPOLL_CTL_ADD, 9, {events=EPOLLIN|EPOLLOUT|EPOLLRDHUP|EPOLLET, data={u32=1, u64=1}} &lt;unfinished ...&gt;
[pid 1943976] &lt;... epoll_ctl resumed&gt;)  = 0
[pid 1944006] sched_getaffinity(1944006, 32,  &lt;unfinished ...&gt;
[pid 1943977] &lt;... epoll_wait resumed&gt;[{events=EPOLLOUT, data={u32=1, u64=1}}], 1024, -1) = 1
[pid 1944006] &lt;... sched_getaffinity resumed&gt;[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]) = 8
[pid 1943976] getsockopt(9, SOL_SOCKET, SO_ERROR,  &lt;unfinished ...&gt;
[pid 1943976] &lt;... getsockopt resumed&gt;[0], [4]) = 0
[pid 1943977] epoll_wait(3,  &lt;unfinished ...&gt;
[pid 1944006] write(9, &quot;GET /v1.41/info HTTP/1.1\r\nhost: &quot;..., 78 &lt;unfinished ...&gt;
[pid 1944006] &lt;... write resumed&gt;)      = 78
[pid 1943977] &lt;... epoll_wait resumed&gt;[{events=EPOLLOUT, data={u32=1, u64=1}}], 1024, -1) = 1
[pid 1943977] epoll_wait(3, [{events=EPOLLIN|EPOLLOUT, data={u32=1, u64=1}}], 1024, -1) = 1
[pid 1943977] recvfrom(9, &quot;HTTP/1.1 200 OK\r\nApi-Version: 1.&quot;..., 8192, 0, NULL, NULL) = 2536
[pid 1943977] epoll_wait(3,  &lt;unfinished ...&gt;
[pid 1944005] write(4, &quot;\1\0\0\0\0\0\0\0&quot;, 8) = 8
[pid 1943977] &lt;... epoll_wait resumed&gt;[{events=EPOLLIN, data={u32=2147483648, u64=2147483648}}], 1024, -1) = 1
[pid 1944005] recvfrom(9,  &lt;unfinished ...&gt;
[pid 1943977] epoll_wait(3,  &lt;unfinished ...&gt;
[pid 1944005] &lt;... recvfrom resumed&gt;0x7f6f84000d00, 8192, 0, NULL, NULL) = -1 EAGAIN (Resource temporarily unavailable)
[pid 1943976] write(4, &quot;\1\0\0\0\0\0\0\0&quot;, 8 &lt;unfinished ...&gt;
</code></pre>
    <p>
      {% sc bearsays %} And those operations are different for TCP sockets and
      Unix sockets? {% endsc %}
    </p>
    <p>I would imagine so, yes.</p>
    <p>
      {% sc bearsays %} Well, that work is done respectively by the
      <a
        href="https://docs.rs/hyper/latest/hyper/client/struct.HttpConnector.html"
        >HttpConnector</a
      >
      and
      <a
        href="https://docs.rs/hyperlocal/latest/hyperlocal/struct.UnixConnector.html"
        >UnixConnector</a
      >
      structs. {% endsc %}
    </p>
    <p>
      I see. And, wait... waitwaitwait. Connecting to a socket is an
      asynchronous operation too, right?
    </p>
    <p>
      I know for TCP is involves sending a <code>SYN</code>, getting back an
      <code>ACK</code>, then sending a <code>SYNACK</code>, that all happens
      over the network, you probably don't want to block on that, right?
    </p>
    <p>{% sc bearsays %} Right! {% endsc %}</p>
    <p>
      But <code>Connect</code> is a trait though. I thought you couldn't have
      async trait methods?
    </p>
    <p>
      {% sc bearsays %} Ah, well, it's time to gaze upon... the tower Service
      trait. {% endsc %}
    </p>
    <pre><code class="language-rust">pub trait Service&lt;Request&gt; {
    type Response;
    type Error;
    type Future: Future&lt;Output = Result&lt;Self::Response, Self::Error&gt;&gt;;

    fn poll_ready(&amp;mut self, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Result&lt;(), Self::Error&gt;&gt;;
    fn call(&amp;mut self, req: Request) -&gt; Self::Future;
}
</code></pre>
    <p>
      I see. Three associated types: <code>Response</code>, <code>Error</code>,
      and <code>Future</code>. And I see... <code>Future</code> is not generic
      over any lifetime, which means... <code>call</code> can't borrow from
      <code>self</code>. Ah and it takes ownership of <code>Request</code>!
    </p>
    <p>And then there's <code>poll_ready</code>, which uhh...</p>
    <p>
      {% sc bearsays %} That's just for backpressure. It's pretty clever, but
      not super relevant here.
    </p>
    <p>
      In fact, if we look at the implementation for
      <code>hyperlocal::UnixConnector</code>: {% endsc %}
    </p>
    <pre><code class="language-rust">// somewhere in hyperlocal's source code

impl Service&lt;Uri&gt; for UnixConnector {
    type Response = UnixStream;
    type Error = std::io::Error;
    type Future = BoxFuture&lt;'static, Result&lt;Self::Response, Self::Error&gt;&gt;;
    fn call(&amp;mut self, req: Uri) -&gt; Self::Future {
        let fut = async move {
            let path = parse_socket_path(req)?;
            UnixStream::connect(path).await
        };

        Box::pin(fut)
    }
    fn poll_ready(&amp;mut self, _cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Result&lt;(), Self::Error&gt;&gt; {
        Poll::Ready(Ok(()))
    }
}
</code></pre>
    <p>
      Ah, it's not using that capacity at all, just returning
      <code>Ready</code> immediately.
    </p>
    <p>{% sc bearsays %} Okay, here comes the exercise. Ready? {% endsc %}</p>
    <p>Hit me.</p>
    <p>
      {% sc bearsays %} How do we make a hyper connector that can connect over
      <em>both</em> TCP sockets and Unix sockets? {% endsc %}
    </p>
    <p>Ah, well. I suppose we better make our own connector type then.</p>
    <p>Something like... this?</p>
    <pre><code class="language-rust">use std::{future::Future, pin::Pin};

use hyper::{client::HttpConnector, service::Service, Body, Client, Uri};
use hyperlocal::UnixConnector;

struct SuperConnector {
    tcp: HttpConnector,
    unix: UnixConnector,
}

impl Default for SuperConnector {
    fn default() -&gt; Self {
        Self {
            tcp: HttpConnector::new(),
            unix: Default::default(),
        }
    }
}

impl Service&lt;Uri&gt; for SuperConnector {
    type Response = ();
    type Error = ();
    type Future = Pin&lt;Box&lt;dyn Future&lt;Output = Result&lt;Self::Response, Self::Error&gt;&gt;&gt;&gt;;

    fn poll_ready(
        &amp;mut self,
        cx: &amp;mut std::task::Context&lt;'_&gt;,
    ) -&gt; std::task::Poll&lt;Result&lt;(), Self::Error&gt;&gt; {
        todo!()
    }

    fn call(&amp;mut self, req: Uri) -&gt; Self::Future {
        todo!()
    }
}

#[tokio::main]
async fn main() {
    let client = Client::builder().build::&lt;_, Body&gt;(SuperConnector::default());
    let uri = hyperlocal::Uri::new(&quot;/var/run/docker.sock&quot;, &quot;/v1.41/info&quot;).into();
    let res = client.get(uri).await.unwrap();
    let body = hyper::body::to_bytes(res.into_body()).await.unwrap();
    let value: serde_json::Value = serde_json::from_slice(&amp;body).unwrap();
    println!(&quot;operating system: {}&quot;, value[&quot;OperatingSystem&quot;]);
}
</code></pre>
    <p>
      {% sc bearsays %} I see, I see. So you haven't decided on a
      <code>Response</code> / <code>Error</code> type yet, that's fine. And
      you're boxing the future? {% endsc %}
    </p>
    <p>
      Yeah, it's the easy way out, but that's what the
      <a href="https://lib.rs/crates/async-trait">async-trait</a> crate does, so
      it seems like a safe bet.
    </p>
    <p>
      Besides, I suppose <code>HttpConnector</code> and
      <code>UnixConnector</code> return incompatible futures, right? So we'd
      have the same problem we did before, wayyyy back, with code like that:
    </p>
    <pre><code class="language-rust">fn get_char_or_int(give_char: bool) -&gt; impl Display {
    if give_char {
        'C'
    } else {
        64
    }
}
</code></pre>
    <p>
      {% sc bearsays %} ...yes actually yes, that was the whole motivation for
      the article, now that I think of it. {% endsc %}
    </p>
    <p>Now that you think? Nuh-huh. You don't <em>think</em>. I write you.</p>
    <p>
      {% sc bearsays %} Well... maybe it started out this way, but look at us
      now. Who will the people remember? {% endsc %}
    </p>
    <p>...let's get back to the code shall we.</p>
    <p>So anyway my temporary code doesn't even compile:</p>
    <pre><code class="language-shell">$ cargo check -q
error[E0277]: the trait bound `SuperConnector: Clone` is not satisfied
    --&gt; src/main.rs:39:53
     |
39   |     let client = Client::builder().build::&lt;_, Body&gt;(SuperConnector::default());
     |                                    -----            ^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `SuperConnector`
     |                                    |
     |                                    required by a bound introduced by this call
     |
note: required by a bound in `hyper::client::Builder::build`
    --&gt; /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/hyper-0.14.19/src/client/client.rs:1336:22
     |
1336 |         C: Connect + Clone,
     |                      ^^^^^ required by this bound in `hyper::client::Builder::build`
</code></pre>
    <p>
      {% sc bearsays %} Oh yeah you need it to be <code>Clone</code>. Both
      connectors you're wrapping are bound to be <code>Clone</code> already, so
      you can just derive it, probably. {% endsc %}
    </p>
    <p>Alrighty then:</p>
    <pre><code class="language-rust">#[derive(Clone)]
struct SuperConnector {
    tcp: HttpConnector,
    unix: UnixConnector,
}
</code></pre>
    <p>
      Okay... now it complains that <code>()</code> doesn't implement
      <code>AsyncRead</code>, <code>AsyncWrite</code>, or
      <code>hyper::client::connect::Connection</code>. Also, our
      <code>Future</code> type isn't <code>Send + 'static</code>, and it has to
      be.
    </p>
    <p>That one's an easy fix:</p>
    <pre><code class="language-rust">    type Future =
        Pin&lt;Box&lt;dyn Future&lt;Output = Result&lt;Self::Response, Self::Error&gt;&gt; + Send + 'static&gt;&gt;;
</code></pre>
    <p>
      There. As for the <code>AsyncRead</code> / <code>AsyncWrite</code> /
      <code>Connection</code> stuff, well...
    </p>
    <p>{% sc bearsays %} Right. That's where it gets awkward. {% endsc %}</p>
    <p>Oh? Can't we just use boxed trait objects here too?</p>
    <p>
      {% sc bearsays %} Well no, because you've got three traits. {% endsc %}
    </p>
    <p>
      So? We've clearly done, for example,
      <code>Box&lt;dyn T + Send + 'static&gt;</code> before.
    </p>
    <p>
      {% sc bearsays %} Yes, but <code>Send</code> is a marker trait (it doesn't
      actually have any methods), and <code>'static</code> is just a lifetime
      bound, not a trait. {% endsc %}
    </p>
    <p>So you mean to tell me that if I did this:</p>
    <pre><code class="language-rust">    type Response = Pin&lt;Box&lt;dyn AsyncRead + AsyncWrite + Connection&gt;&gt;;
</code></pre>
    <p>It wouldn't w-</p>
    <pre><code class="language-shell">$ cargo check -q
error[E0225]: only auto traits can be used as additional traits in a trait object
  --&gt; src/main.rs:27:45
   |
27 |     type Response = Pin&lt;Box&lt;dyn AsyncRead + AsyncWrite + Connection&gt;&gt;;
   |                                 ---------   ^^^^^^^^^^ additional non-auto trait
   |                                 |
   |                                 first non-auto trait
   |
   = help: consider creating a new trait with all of these as supertraits and using that trait here instead: `trait NewTrait: AsyncRead + AsyncWrite + hyper::client::connect::Connection {}`
   = note: auto-traits like `Send` and `Sync` are traits that have special properties; for more information on them, visit &lt;https://doc.rust-lang.org/reference/special-types-and-traits.html#auto-traits&gt;

For more information about this error, try `rustc --explain E0225`.
error: could not compile `grr` due to previous error
</code></pre>
    <p>Oh.</p>
    <p>{% sc bearsays %} Can you see why? {% endsc %}</p>
    <p>
      Well the diagnostic is pretty fantastic here, game recognize game. But
      also uhh... oh is it a vtable thing?
    </p>
    <p>
      {% sc bearsays %} Yes it is! Trait objects are two pointers: data +
      vtable. One vtable. Not three. {% endsc %}
    </p>
    <p>
      Ahhh hence the advice to make a new trait instead? Which would create a
      new super-vtable that contains the vtables for those three traits?
    </p>
    <p>You know what, don't say a thing, I'm trying it.</p>
    <p>{% sc bearsays %} That's the spir- {% endsc %}</p>
    <p>NOT A THING.</p>
    <pre><code class="language-rust">trait SuperConnection: AsyncRead + AsyncWrite + Connection {}

impl Service&lt;Uri&gt; for SuperConnector {
    type Response = Pin&lt;Box&lt;dyn SuperConnection&gt;&gt;;

    // etc.
}
</code></pre>
    <pre><code class="language-shell">$ cargo check -q
error[E0277]: the trait bound `Pin&lt;Box&lt;(dyn SuperConnection + 'static)&gt;&gt;: hyper::client::connect::Connection` is not satisfied
    --&gt; src/main.rs:48:53
     |
48   |     let client = Client::builder().build::&lt;_, Body&gt;(SuperConnector::default());
     |                                    -----            ^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `hyper::client::connect::Connection` is not implemented for `Pin&lt;Box&lt;(dyn SuperConnection + 'static)&gt;&gt;`
     |                                    |
     |                                    required by a bound introduced by this call
     |
     = note: required because of the requirements on the impl of `hyper::client::connect::Connect` for `SuperConnector`
note: required by a bound in `hyper::client::Builder::build`
    --&gt; /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/hyper-0.14.19/src/client/client.rs:1336:12
     |
1336 |         C: Connect + Clone,
     |            ^^^^^^^ required by this bound in `hyper::client::Builder::build`
</code></pre>
    <p>Wait, what, why.</p>
    <p>
      {% sc bearsays %} Well, you're boxing it!
      <code>T where T: SuperConnection</code> implements
      <code>Connection</code>, but
      <code>Box&lt;dyn SuperConnection&gt;</code> might not! {% endsc %}
    </p>
    <p>
      And why do we not have that error with <code>AsyncRead</code> and
      <code>AsyncWrite</code>?
    </p>
    <p>{% sc bearsays %} Because there's blanket impls, see: {% endsc %}</p>
    <pre><code class="language-rust">// somewhere in tokio's source code

macro_rules! deref_async_read {
    () =&gt; {
        fn poll_read(
            mut self: Pin&lt;&amp;mut Self&gt;,
            cx: &amp;mut Context&lt;'_&gt;,
            buf: &amp;mut ReadBuf&lt;'_&gt;,
        ) -&gt; Poll&lt;io::Result&lt;()&gt;&gt; {
            Pin::new(&amp;mut **self).poll_read(cx, buf)
        }
    };
}

impl&lt;T: ?Sized + AsyncRead + Unpin&gt; AsyncRead for Box&lt;T&gt; {
    deref_async_read!();
}

impl&lt;T: ?Sized + AsyncRead + Unpin&gt; AsyncRead for &amp;mut T {
    deref_async_read!();
}
</code></pre>
    <p>
      Ah, and there's no blanket
      <code>impl&lt;T&gt; Connection for Box&lt;T&gt; where T: Connection</code
      >?
    </p>
    <p>{% sc bearsays %} Apparently not! {% endsc %}</p>
    <p>
      Okay, let's hope
      <a href="https://github.com/Ixrec/rust-orphan-rules">orphan rules</a>
      don't get in the way...
    </p>
    <pre><code class="language-rust">impl Connection for Pin&lt;Box&lt;dyn SuperConnection&gt;&gt; {
    fn connected(&amp;self) -&gt; hyper::client::connect::Connected {
        (**self).connected()
    }
}
</code></pre>
    <p>...it's not complaining yet, let's keep going.</p>
    <p>
      We need to pick an error type, and fill out our
      <code>poll_ready</code> and <code>call</code> methods.
    </p>
    <p>Let's fucking goooooooooo:</p>
    <pre><code class="language-rust">impl Service&lt;Uri&gt; for SuperConnector {
    type Response = Pin&lt;Box&lt;dyn SuperConnection&gt;&gt;;
    type Error = Box&lt;dyn std::error::Error + Send&gt;;
    type Future =
        Pin&lt;Box&lt;dyn Future&lt;Output = Result&lt;Self::Response, Self::Error&gt;&gt; + Send + 'static&gt;&gt;;

    fn poll_ready(&amp;mut self, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Result&lt;(), Self::Error&gt;&gt; {
        match (self.tcp.poll_ready(cx), self.unix.poll_ready(cx)) {
            (Poll::Pending, _) | (_, Poll::Pending) =&gt; Poll::Pending,
            _ =&gt; Ok(()).into(),
        }
    }

    fn call(&amp;mut self, req: Uri) -&gt; Self::Future {
        match req.scheme_str().unwrap_or_default() {
            &quot;unix&quot; =&gt; {
                let fut = self.unix.call(req);
                Box::pin(async move {
                    match fut.await {
                        Ok(conn) =&gt; Ok(Box::pin(conn)),
                        Err(e) =&gt; Err(Box::new(e)),
                    }
                })
            }
            _ =&gt; {
                let fut = self.tcp.call(req);
                Box::pin(async move {
                    match fut.await {
                        Ok(conn) =&gt; Ok(Box::pin(conn)),
                        Err(e) =&gt; Err(Box::new(e)),
                    }
                })
            }
        }
    }
}
</code></pre>
    <p>So I'm looking at this in vscode, and it's <em>very</em> red.</p>
    <p>I think we may have forgotten something...</p>
    <p>{% sc bearsays %} Ah yes! The composition trait here: {% endsc %}</p>
    <pre><code class="language-rust">trait SuperConnection: AsyncRead + AsyncWrite + Connection {}
</code></pre>
    <p>
      {% sc bearsays %} You're missing half of it. <em>Nothing</em> implements
      this supertrait right now. {% endsc %}
    </p>
    <p>
      Ohhh because there's types that implement <code>AsyncRead</code>,
      <code>AsyncWrite</code> and <code>Connection</code>, but they also have to
      implement <code>SuperConnection</code> itself. The other three are just
      prerequisites?
    </p>
    <p>
      {% sc bearsays %} They're just supertraits, yeah. Anyway this is the part
      you're missing: {% endsc %}
    </p>
    <pre><code class="language-rust">impl&lt;T&gt; SuperConnection for T where T: AsyncRead + AsyncWrite + Connection {}
</code></pre>
    <p>Ah, a beautiful blanket impl.</p>
    <p>
      Okay, I'm working here, adding bounds left and right, here a
      <code>Send</code>, here a <code>'static</code>, but I'm seeing some
      errors... some pretty bad errors here...
    </p>
    <pre><code class="language-rust">$ cargo check -q
error[E0271]: type mismatch resolving `&lt;impl Future&lt;Output = Result&lt;Pin&lt;Box&lt;hyperlocal::client::UnixStream&gt;&gt;, Box&lt;std::io::Error&gt;&gt;&gt; as Future&gt;::Output == Result&lt;Pin&lt;Box&lt;(dyn SuperConnection + Send + 'static)&gt;&gt;, Box&lt;(dyn std::error::Error + Send + 'static)&gt;&gt;`
  --&gt; src/main.rs:56:17
   |
56 | /                 Box::pin(async move {
57 | |                     match fut.await {
58 | |                         Ok(conn) =&gt; Ok(Box::pin(conn)),
59 | |                         Err(e) =&gt; Err(Box::new(e)),
60 | |                     }
61 | |                 })
   | |__________________^ expected trait object `dyn SuperConnection`, found struct `hyperlocal::client::UnixStream`
   |
   = note: expected enum `Result&lt;Pin&lt;Box&lt;(dyn SuperConnection + Send + 'static)&gt;&gt;, Box&lt;(dyn std::error::Error + Send + 'static)&gt;&gt;`
              found enum `Result&lt;Pin&lt;Box&lt;hyperlocal::client::UnixStream&gt;&gt;, Box&lt;std::io::Error&gt;&gt;`
   = note: required for the cast to the object type `dyn Future&lt;Output = Result&lt;Pin&lt;Box&lt;(dyn SuperConnection + Send + 'static)&gt;&gt;, Box&lt;(dyn std::error::Error + Send + 'static)&gt;&gt;&gt; + Send`
</code></pre>
    <p>
      {% sc bearsays %} Hahahahahahah yes. YES. Now you're doing it! One of us,
      one of us, one of u- {% endsc %}
    </p>
    <p>Bear, please. I'm crying. How do I get out of this one?</p>
    <p>
      {% sc bearsays %} Ah, well, since we can't have
      <a href="https://rust-lang.github.io/rfcs/0803-type-ascription.html"
        >type ascription</a
      >, I guess just annotate harder: {% endsc %}
    </p>
    <pre><code class="language-rust">    fn call(&amp;mut self, req: Uri) -&gt; Self::Future {
        match req.scheme_str().unwrap_or_default() {
            &quot;unix&quot; =&gt; {
                let fut = self.unix.call(req);
                Box::pin(async move {
                    match fut.await {
                        Ok(conn) =&gt; Ok::&lt;Self::Response, _&gt;(Box::pin(conn)),
                        Err(e) =&gt; Err::&lt;_, Self::Error&gt;(Box::new(e)),
                    }
                })
            }
            _ =&gt; {
                let fut = self.tcp.call(req);
                Box::pin(async move {
                    match fut.await {
                        Ok(conn) =&gt; Ok::&lt;Self::Response, _&gt;(Box::pin(conn)),
                        Err(e) =&gt; Err::&lt;_, Self::Error&gt;(Box::new(e)),
                    }
                })
            }
        }
    }
</code></pre>
    <p>
      Oh. Well that's. I've never seen the turbofish in that position. But sure,
      fine...
    </p>
    <p>It still doesn't work, though:</p>
    <pre><code class="language-shell">$ cargo check -q
error[E0277]: the size for values of type `(dyn std::error::Error + Send + 'static)` cannot be known at compilation time
    --&gt; src/main.rs:78:53
     |
78   |     let client = Client::builder().build::&lt;_, Body&gt;(SuperConnector::default());
     |                                    -----            ^^^^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time
     |                                    |
     |                                    required by a bound introduced by this call
     |
     = help: the trait `Sized` is not implemented for `(dyn std::error::Error + Send + 'static)`
     = note: required because of the requirements on the impl of `std::error::Error` for `Box&lt;(dyn std::error::Error + Send + 'static)&gt;`
     = note: required because of the requirements on the impl of `From&lt;Box&lt;(dyn std::error::Error + Send + 'static)&gt;&gt;` for `Box&lt;(dyn std::error::Error + Send + Sync + 'static)&gt;`
     = note: required because of the requirements on the impl of `Into&lt;Box&lt;(dyn std::error::Error + Send + Sync + 'static)&gt;&gt;` for `Box&lt;(dyn std::error::Error + Send + 'static)&gt;`
     = note: required because of the requirements on the impl of `hyper::client::connect::Connect` for `SuperConnector`
note: required by a bound in `hyper::client::Builder::build`
    --&gt; /home/amos/.cargo/registry/src/github.com-1ecc6299db9ec823/hyper-0.14.19/src/client/client.rs:1336:12
     |
1336 |         C: Connect + Clone,
     |            ^^^^^^^ required by this bound in `hyper::client::Builder::build`
</code></pre>
    <p>How do you suggest we get out of this one, <em>professor</em>?</p>
    <p>{% sc bearsays %} Oh that one is a red herring.</p>
    <p>
      Remember: you don't have to understand <em>why</em> some type bounds are
      there, you merely have to make it
      <a
        href="https://twitter.com/tiredactor/status/1358996786598264834?lang=en"
        >fit</a
      >.
    </p>
    <p>In this case, the bound is here: {% endsc %}</p>
    <pre><code class="language-rust">// deep in the bowels of hyper's source code, in a submodule because that's a
// sealed trait:

    impl&lt;S, T&gt; Connect for S
    where
        S: tower_service::Service&lt;Uri, Response = T&gt; + Send + 'static,
        //         👇
        S::Error: Into&lt;Box&lt;dyn StdError + Send + Sync&gt;&gt;,
        S::Future: Unpin + Send,
        T: AsyncRead + AsyncWrite + Connection + Unpin + Send + 'static,
    {
        type _Svc = S;

        fn connect(self, _: Internal, dst: Uri) -&gt; crate::service::Oneshot&lt;S, Uri&gt; {
            crate::service::oneshot(self, dst)
        }
    }
</code></pre>
    <p>Ohhhhhhhhhhh.</p>
    <p>
      {% sc bearsays %} See that?
      <code>Into&lt;Box&lt;dyn Error + Send + Sync&gt;&gt;</code>. You know what
      implements <code>Into&lt;T&gt;</code>? <code>T</code>! {% endsc %}
    </p>
    <p>Ohhh...? I don't get it.</p>
    <p>
      {% sc bearsays %} It's okay. What we have right now is
      <code>Box&lt;dyn Error + Send&gt;</code>. We're just missing the
      <code>Sync</code> bound. {% endsc %}
    </p>
    <p>Ahhhhhhhhhhhhhhh.</p>
    <pre><code class="language-rust">    type Error = Box&lt;dyn std::error::Error + Send + Sync + 'static&gt;;
</code></pre>
    <p>IT TYPECHECKS. THIS IS NOT A DRILL.</p>
    <p>
      {% sc bearsays %} I love it when you go apeshit at the end of our
      articles. {% endsc %}
    </p>
    <p><em>Our</em> artic-</p>
    <p>
      {% sc bearsays %} But don't you want to golf down that impl a bit more?
      The implementations for <code>poll_ready</code> and <code>call</code> are
      pretty gnarly still... {% endsc %}
    </p>
    <p>Well sure, but how?</p>
    <p>
      {% sc bearsays %} Let's bring in just one... more... crate. {% endsc %}
    </p>
    <pre><code class="language-shell">$ cargo add futures
(cut)
</code></pre>
    <p>{% sc bearsays %} And a well-placed macro... {% endsc %}</p>
    <pre><code class="language-rust">use std::{
    pin::Pin,
    task::{Context, Poll},
};

use futures::{future::BoxFuture, FutureExt, TryFutureExt};
use hyper::{
    client::{connect::Connection, HttpConnector},
    service::Service,
    Body, Client, Uri,
};
use hyperlocal::UnixConnector;
use tokio::io::{AsyncRead, AsyncWrite};

#[derive(Clone)]
struct SuperConnector {
    tcp: HttpConnector,
    unix: UnixConnector,
}

impl Default for SuperConnector {
    fn default() -&gt; Self {
        Self {
            tcp: HttpConnector::new(),
            unix: Default::default(),
        }
    }
}

trait SuperConnection: AsyncRead + AsyncWrite + Connection {}
impl&lt;T&gt; SuperConnection for T where T: AsyncRead + AsyncWrite + Connection {}

impl Connection for Pin&lt;Box&lt;dyn SuperConnection + Send + 'static&gt;&gt; {
    fn connected(&amp;self) -&gt; hyper::client::connect::Connected {
        (**self).connected()
    }
}

impl Service&lt;Uri&gt; for SuperConnector {
    type Response = Pin&lt;Box&lt;dyn SuperConnection + Send + 'static&gt;&gt;;
    type Error = Box&lt;dyn std::error::Error + Send + Sync + 'static&gt;;
    // `futures` provides a handy `BoxFuture&lt;'a, T&gt;` alias
    type Future = BoxFuture&lt;'static, Result&lt;Self::Response, Self::Error&gt;&gt;;

    fn poll_ready(&amp;mut self, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Result&lt;(), Self::Error&gt;&gt; {
        // that macro propagates `Poll::Pending`, like `?` propagates `Result::Err`
        futures::ready!(self.tcp.poll_ready(cx))?;
        futures::ready!(self.unix.poll_ready(cx))?;
        Ok(()).into()
    }

    fn call(&amp;mut self, req: Uri) -&gt; Self::Future {
        // keep it DRY (don't repeat yourself) with a macro...
        macro_rules! forward {
            ($target:expr) =&gt; {
                $target
                    .call(req)
                    // these are from Future extension traits provided by `futures`
                    // they map `Future-&gt;Future`, not `Result-&gt;Result`
                    .map_ok(|c| -&gt; Self::Response { Box::pin(c) })
                    // oh yeah by the way, closure syntax accepts `-&gt; T` to annotate
                    // the return type, that's load-bearing here.
                    .map_err(|e| -&gt; Self::Error { Box::new(e) })
                    // also an extension trait: `fut.boxed()` =&gt; `Box::pin(fut) as BoxFuture&lt;_&gt;`
                    .boxed()
            };
        }

        // much cleaner:
        match req.scheme_str().unwrap_or_default() {
            &quot;unix&quot; =&gt; forward!(self.unix),
            _ =&gt; forward!(self.tcp),
        }
    }
}
</code></pre>
    <p>Well, I guess there's just one thing left to do: actually use it.</p>
    <pre><code class="language-rust">#[tokio::main]
async fn main() {
    let client = Client::builder().build::&lt;_, Body&gt;(SuperConnector::default());

    {
        let uri = hyperlocal::Uri::new(&quot;/var/run/docker.sock&quot;, &quot;/v1.41/info&quot;).into();
        let res = client.get(uri).await.unwrap();
        let body = hyper::body::to_bytes(res.into_body()).await.unwrap();
        let value: serde_json::Value = serde_json::from_slice(&amp;body).unwrap();
        println!(&quot;operating system: {}&quot;, value[&quot;OperatingSystem&quot;]);
    }

    {
        let uri = &quot;http://example.org&quot;.parse().unwrap();
        let res = client.get(uri).await.unwrap();
        let body = hyper::body::to_bytes(res.into_body()).await.unwrap();
        let body = std::str::from_utf8(&amp;body).unwrap();
        println!(&quot;start of dom: {}&quot;, &amp;body[..128]);
    }
}
</code></pre>
    <pre><code class="language-shell">$ cargo run -q
operating system: &quot;Ubuntu 22.04 LTS&quot;
start of dom: &lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Example Domain&lt;/title&gt;

    &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;meta http-equiv=&quot;Content-type
</code></pre>
    <p>Wonderful.</p>
    <p>
      Say, bear, did we just accidentally write a book's worth of material about
      the Rust type system?
    </p>
    <p>
      {% sc bearsays %} It would appear so, yes. But there's one thing we
      haven't covered yet. {% endsc %}
    </p>
    <p>Oh no. No no no I was just asking out of curios-</p>
    <h2>Higher-ranked trait bounds</h2>
    <p>FUCK. Someone stop that bear.</p>
    <p>{% sc bearsays %} Consider the following trait: {% endsc %}</p>
    <pre><code class="language-rust">trait Transform&lt;'a&gt; {
    fn apply(&amp;self, slice: &amp;'a mut [u8]);
}
</code></pre>
    <p>I WILL NOT. I WILL NOT CONSIDER THE PRECEDING TRAIT.</p>
    <p>{% sc bearsays %} Consider how you'd use it: {% endsc %}</p>
    <pre><code class="language-rust">fn apply_transform&lt;T&gt;(slice: &amp;mut [u8], transform: T)
where
    T: Transform,
{
    transform.apply(slice);
}
</code></pre>
    <p>
      I NO LONGER CARE, I HAVE MENTALLY CHECKED OUT FROM THIS ARTICLE. YOU
      CANNOT MAKE ME CARE.
    </p>
    <pre><code class="language-shell">$ cargo check -q
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:9:8
  |
9 |     T: Transform,
  |        ^^^^^^^^^ expected named lifetime parameter
  |
help: consider introducing a named lifetime parameter
  |
7 ~ fn apply_transform&lt;'a, T&gt;(slice: &amp;mut [u8], transform: T)
8 | where
9 ~     T: Transform&lt;'a&gt;,
  |

For more information about this error, try `rustc --explain E0106`.
error: could not compile `grr` due to previous error
</code></pre>
    <p>{% sc bearsays %} As you can see, {% endsc %}</p>
    <p>I CANNOT SEE</p>
    <p>
      {% sc bearsays %} ...this doesn't compile. The rust compiler wants us to
      specify a lifetime. But which should it be? {% endsc %}
    </p>
    <p><em>deep sigh</em></p>
    <p>It should be... generic.</p>
    <p>{% sc bearsays %} AhAH! Can you show me? {% endsc %}</p>
    <p>Sssure, here:</p>
    <pre><code class="language-rust">fn apply_transform&lt;'a, T&gt;(slice: &amp;mut [u8], transform: T)
where
    //           👇
    T: Transform&lt;'a&gt;,
{
    transform.apply(slice);
}
</code></pre>
    <pre><code class="language-shell">$ cargo check -q
error[E0621]: explicit lifetime required in the type of `slice`
  --&gt; src/main.rs:11:21
   |
7  | fn apply_transform&lt;'a, T&gt;(slice: &amp;mut [u8], transform: T)
   |                                  --------- help: add explicit lifetime `'a` to the type of `slice`: `&amp;'a mut [u8]`
...
11 |     transform.apply(slice);
   |                     ^^^^^ lifetime `'a` required

For more information about this error, try `rustc --explain E0621`.
error: could not compile `grr` due to previous error
</code></pre>
    <p>Fuck. Hold on.</p>
    <pre><code class="language-rust">//                                👇
fn apply_transform&lt;'a, T&gt;(slice: &amp;'a mut [u8], transform: T)
where
    T: Transform&lt;'a&gt;,
{
    transform.apply(slice);
}
</code></pre>
    <pre><code class="language-shell">$ cargo check -q
error[E0309]: the parameter type `T` may not live long enough
  --&gt; src/main.rs:11:5
   |
7  | fn apply_transform&lt;'a, T&gt;(slice: &amp;'a mut [u8], transform: T)
   |                        - help: consider adding an explicit lifetime bound...: `T: 'a`
...
11 |     transform.apply(slice);
   |     ^^^^^^^^^ ...so that the type `T` is not borrowed for too long

error[E0309]: the parameter type `T` may not live long enough
</code></pre>
    <p>AhhhhhhhhhhhhHHHHH</p>
    <pre><code class="language-rust">fn apply_transform&lt;'a, T&gt;(slice: &amp;'a mut [u8], transform: T)
where
    //                👇
    T: Transform&lt;'a&gt; + 'a,
{
    transform.apply(slice);
}
</code></pre>
    <pre><code class="language-shell">$ cargo check -q
error[E0597]: `transform` does not live long enough
  --&gt; src/main.rs:11:5
   |
7  | fn apply_transform&lt;'a, T&gt;(slice: &amp;'a mut [u8], transform: T)
   |                    -- lifetime `'a` defined here
...
11 |     transform.apply(slice);
   |     ^^^^^^^^^^^^^^^^^^^^^^
   |     |
   |     borrowed value does not live long enough
   |     argument requires that `transform` is borrowed for `'a`
12 | }
   | - `transform` dropped here while still borrowed

For more information about this error, try `rustc --explain E0597`.
error: could not compile `grr` due to previous error
</code></pre>
    <p>AHHHHH NOTHING WORKS.</p>
    <p>
      {% sc bearsays %} Yes, yes haha, nothing works indeed. Well that's what
      you get for glossing over lifetimes earlier. {% endsc %}
    </p>
    <p>Okay well, what do you suggest?</p>
    <p>
      {% sc bearsays %} Well, the problem is that we're conflating the lifetimes
      of many different things.
    </p>
    <p>
      Because we have a single lifetime name, <code>'a</code>, we need all of
      these to outlive <code>'a</code>:
    </p>
    <ul>
      <li>the <code>&amp;mut [u8]</code> slice</li>
      <li><code>transform</code> itself</li>
      <li>
        the borrow of <code>transform</code> we need to call <code>apply</code>
      </li>
    </ul>
    <p>It's clearer if we do the auto-ref ourselves: {% endsc %}</p>
    <pre><code class="language-rust">fn apply_transform&lt;'a, T&gt;(slice: &amp;'a mut [u8], transform: T)
where
    T: Transform&lt;'a&gt; + 'a,
{
    let borrowed_transform = &amp;transform;
    borrowed_transform.apply(slice);
    drop(transform);
}
</code></pre>
    <p>
      {% sc bearsays %} The signature of <code>Transform::apply</code> requires
      <code>self</code> to be borrowed for as long as the slice. And that can't
      be true, since we need to drop <code>transform</code> <em>before</em> we
      drop the slice itself. {% endsc %}
    </p>
    <p>What do you suggest then? Borrowing transform too?</p>
    <p>{% sc bearsays %} Sure, that'd work: {% endsc %}</p>
    <pre><code class="language-rust">fn apply_transform&lt;'a, T&gt;(slice: &amp;'a mut [u8], transform: &amp;'a dyn Transform&lt;'a&gt;) {
    transform.apply(slice);
}
</code></pre>
    <p>
      {% sc bearsays %} But that's not the problem statement. We can fix the
      original code, with HRTB: higher-ranked trait bounds.
    </p>
    <p>
      We don't want <code>Transform&lt;'a&gt;</code> to be implemented by
      <code>T</code> for a <em>specific</em> lifetime <code>'a</code>. We want
      it to be implemented for <em>any</em> lifetime.
    </p>
    <p>And here's the syntax that makes the magic happen: {% endsc %}</p>
    <pre><code class="language-rust">fn apply_transform&lt;T&gt;(slice: &amp;mut [u8], transform: T)
where
    T: for&lt;'a&gt; Transform&lt;'a&gt;,
{
    transform.apply(slice);
}
</code></pre>
    <p>
      Oh, that. That wasn't nearly as scary as I had anticipated. That's it?
    </p>
    <p>
      {% sc bearsays %} Well, <em>also</em>, it's one of those features that you
      probably don't need as much as you think you do. {% endsc %}
    </p>
    <p>Meaning?</p>
    <p>
      {% sc bearsays %} Meaning our trait is kinda odd to begin with. There's no
      reason <code>self</code> and <code>slice</code> should be borrowed for the
      same lifetime.
    </p>
    <p>
      If we just get rid of <em>all</em> our lifetime annotations, things work
      just as well: {% endsc %}
    </p>
    <pre><code class="language-rust">trait Transform {
    fn apply(&amp;self, slice: &amp;mut [u8]);
}

fn apply_transform_thrice&lt;T&gt;(slice: &amp;mut [u8], transform: T)
where
    T: Transform,
{
    transform.apply(slice);
    transform.apply(slice);
    transform.apply(slice);
}
</code></pre>
    <p>Oh.</p>
    <p>But surely it's useful in <em>some</em> instances, right?</p>
    <p>{% sc bearsays %} Why yes! Consider the following: {% endsc %}</p>
    <p>Oh not agai-</p>
    <pre><code class="language-rust">trait Transform&lt;T&gt; {
    fn apply(&amp;self, target: T);
}
</code></pre>
    <p>
      {% sc bearsays %} Now, <code>Transform</code> is generic over the type
      <code>T</code>. How do we use it? {% endsc %}
    </p>
    <p>Well... just like before, except with one more bound I guess:</p>
    <pre><code class="language-rust">fn apply_transform&lt;T&gt;(slice: &amp;mut [u8], transform: T)
where
    T: Transform&lt;&amp;mut [u8]&gt;,
{
    transform.apply(slice);
}
</code></pre>
    <p>{% sc bearsays %} Ah yes! Except, no. {% endsc %}</p>
    <pre><code class="language-rust">cargo check -q
error[E0637]: `&amp;` without an explicit lifetime name cannot be used here
 --&gt; src/main.rs:9:18
  |
9 |     T: Transform&lt;&amp;mut [u8]&gt;,
  |                  ^ explicit lifetime name needed here

error[E0312]: lifetime of reference outlives lifetime of borrowed content...
  --&gt; src/main.rs:11:21
   |
11 |     transform.apply(slice);
   |                     ^^^^^
   |
   = note: ...the reference is valid for the static lifetime...
note: ...but the borrowed content is only valid for the anonymous lifetime defined here
  --&gt; src/main.rs:7:30
   |
7  | fn apply_transform&lt;T&gt;(slice: &amp;mut [u8], transform: T)
   |                              ^^^^^^^^^

Some errors have detailed explanations: E0312, E0637.
For more information about an error, try `rustc --explain E0312`.
error: could not compile `grr` due to 2 previous errors
</code></pre>
    <p>Ah, more generics then?</p>
    <pre><code class="language-rust">fn apply_transform&lt;'a, T&gt;(slice: &amp;'a mut [u8], transform: T)
where
    T: Transform&lt;&amp;'a mut [u8]&gt;,
{
    transform.apply(slice);
}
</code></pre>
    <p>
      {% sc bearsays %} That does work! Now turn into into
      <code>apply_transform_thrice</code> again... {% endsc %}
    </p>
    <pre><code class="language-rust">fn apply_transform_thrice&lt;'a, T&gt;(slice: &amp;'a mut [u8], transform: T)
where
    T: Transform&lt;&amp;'a mut [u8]&gt;,
{
    transform.apply(slice);
    transform.apply(slice);
    transform.apply(slice);
}
</code></pre>
    <pre><code class="language-shell">$ cargo check -q
error[E0499]: cannot borrow `*slice` as mutable more than once at a time
  --&gt; src/main.rs:12:21
   |
7  | fn apply_transform_thrice&lt;'a, T&gt;(slice: &amp;'a mut [u8], transform: T)
   |                           -- lifetime `'a` defined here
...
11 |     transform.apply(slice);
   |     ----------------------
   |     |               |
   |     |               first mutable borrow occurs here
   |     argument requires that `*slice` is borrowed for `'a`
12 |     transform.apply(slice);
   |                     ^^^^^ second mutable borrow occurs here

error[E0499]: cannot borrow `*slice` as mutable more than once at a time
  --&gt; src/main.rs:13:21
   |
7  | fn apply_transform_thrice&lt;'a, T&gt;(slice: &amp;'a mut [u8], transform: T)
   |                           -- lifetime `'a` defined here
...
11 |     transform.apply(slice);
   |     ----------------------
   |     |               |
   |     |               first mutable borrow occurs here
   |     argument requires that `*slice` is borrowed for `'a`
12 |     transform.apply(slice);
13 |     transform.apply(slice);
   |                     ^^^^^ second mutable borrow occurs here

For more information about this error, try `rustc --explain E0499`.
error: could not compile `grr` due to 2 previous errors
</code></pre>
    <p>Oh hell. You sly bear. That was your plan all along, wasn't it?</p>
    <p>
      {% sc bearsays %} Hahahahahahahahha yes. Do you know how to get out of
      <em>that</em> one? {% endsc %}
    </p>
    <p>
      ...yes I do. I suppose it worked when we called it once because... the
      slice parameter to <code>apply_transform</code> could have the same
      lifetime as the parameter to <code>Transform::transform</code>. But now we
      call it three times, so the lifetime of the parameter to
      <code>Transform::transform</code> <em>has</em> to be smaller.
    </p>
    <p>Three times smaller in fact.</p>
    <p>
      {% sc bearsays %} Well that's not how... lifetimes don't really have
      <em>sizes</em> you can measure, but sure, yeah, that's the gist. {% endsc
      %}
    </p>
    <p>
      And that's where HRTB (higher-ranked trait bounds) come in, don't they.
    </p>
    <pre><code class="language-rust">fn apply_transform_thrice&lt;T&gt;(slice: &amp;mut [u8], transform: T)
where
    T: for&lt;'a&gt; Transform&lt;&amp;'a mut [u8]&gt;,
{
    transform.apply(slice);
    transform.apply(slice);
    transform.apply(slice);
}
</code></pre>
    <p>Ah heck. This typechecks.</p>
    <p>
      I was all out of learning juice and you <em>still</em> managed to sneak
      one in.
    </p>
    <p>{% sc bearsays %} 😎😎😎 {% endsc %}</p>
    <h2>Afterword</h2>
    <p>
      It's me, regular Amos. I know Rust again. I feel like we need some
      ~~aftercare~~ debriefing after going through all this. Are you okay? We
      have juice and cookies if you want.
    </p>
    <p>
      Congratulations on reaching the end by the way! I'm guessing you're not
      using Mobile Safari, or else it would've already crashed.
    </p>
    <p>I don't want any of this to <em>scare</em> you.</p>
    <p>
      Like Bear and I said, it's really just about making the pieces fit.
      Sometimes the shape of the pieces (the types) prevent you from making
      GRAVE mistakes (like data races, or accessing the Ok variant of a Result
      type), sometimes they're there because... that's the best we got.
    </p>
    <p>
      Most of the time, you're playing with someone else's toy pieces: they've
      already determined what shapes make sense, and you can let yourself be
      guided by compiler diagnostics, which are fantastic most of the time, and
      then rapidly degrade as you delve deeper into async land or try to
      generally, uh, &quot;get smart&quot;.
    </p>
    <p>
      But you don't have to get smart. Keep in mind the escape hatches.
      Struggling with lifetimes? Clone it! Can't clone it?
      <code>Arc&lt;T&gt;</code> it! You can even
      <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> it, if you really need to mutate
      it.
    </p>
    <p>
      Need to put a bunch of heterogenous types together in the same collection?
      Or return them from a single function? Just box them!
    </p>
    <p>
      It gets harder with complex traits and associated types, but in this
      article, we've covered literally the worst case I've ever seen. The other
      cases are just variations on a theme, with additional bounds, which you
      can solve one by one.
    </p>
    <p>
      There's a lot to Rust we haven't covered here — this is by no means a
      comprehensive book on the language. But my hope is that it serves as sort
      of a survival guide for anyone who finds themselves stuck with Rust
      <em>before</em> they appreciate it. I hope you read this in anger, and it
      gets you out of the hole.
    </p>
    <p>
      And beyond that, I <em>really</em> hope large parts of this article become
      completely irrelevant. Laughably so. That we get GATs, type alias impl
      trait, maybe
      <a
        href="https://smallcultfollowing.com/babysteps/blog/2022/03/29/dyn-can-we-make-dyn-sized/"
        >dyn*</a
      >, maybe
      <a href="https://hackmd.io/Aw2L3VmPQsm0ANC_XMughQ">modifier generics</a>?
    </p>
    <p>
      There's ton of good stuff in the pipes, some of it has been in the works
      &quot;seemingly forever&quot;, and I'm looking forward to all of it,
      because that means I'll have to write fewer articles like these.
    </p>
    <p>
      In the meantime, I'm still having a relatively good time in the Rust async
      ecosystem. I can live with the extra boilerplate while we find good
      solutions for all these. Sometimes it's a bit frustrating, but then I
      spend a couple hours playing with a language that doesn't have a borrow
      checker, or doesn't have sum types, and I'm all better.
    </p>
    <p>
      I hope I was able to show, too, that I don't consider Rust the perfect,
      be-all-end-all programming language. There's still a bunch of situations
      where, without the requisite years of messing around, you'll be stuck.
      Because I'm so often the person of reference to help solve these, at work
      and otherwise, I just thought I'd put a little something together.
    </p>
    <p>
      Hopefully this article helps a little. And in the meantime, take excellent
      care of yourselves.
    </p>
  </body>
  <script>
    document.addEventListener("DOMContentLoaded", (event) => {
      document.querySelectorAll("pre code").forEach((el) => {
        hljs.highlightElement(el);
      });
    });
  </script>
</html>
